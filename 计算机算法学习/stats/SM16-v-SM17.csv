Date, Element No, Used interval, SM16 Interval (new), SM17 Interval (new), SM17/SM16 Interval ratio, R (SM16), R (SM17)(exp), R (SM17), Grade, Success, abs RM16, abs RM17 (expected), abs RM17 (predicted), abs R-Metric, sqr R-Metric, Title,
May 10 2018 07:03:01,41,4,2,1,0.5,0.817,0.889,0.917,2,0,0.8171,0.8894,0.9168,-0.0996,-0.1727,完全背包模板
May 10 2018 07:03:21,23,19,2,1,0.5,0.288,0.521,0.806,1,0,0.2884,0.5207,0.8056,-0.5172,-0.5659,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:04,42,5,17,22,1.28,0.714,0.858,0.898,4,1,0.2855,0.1424,0.1015,0.184,0.0712,完全背包模板
May 11 2018 08:00:25,41,1,2,7,3.4,0.951,0.896,0.896,4,1,0.0489,0.1038,0.1038,-0.0549,-0.0084,完全背包模板
May 11 2018 08:00:33,23,1,2,7,3.4,0.956,0.896,0.896,4,1,0.0444,0.1038,0.1038,-0.0594,-0.0088,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:50,27,5,15,22,1.46,0.799,0.857,0.898,4,1,0.2013,0.1433,0.1015,0.0998,0.0302,01二维
May 11 2018 08:01:07,12,11,28,26,0.92,0.98,0.95,0.95,4,1,0.0201,0.0503,0.0503,-0.0301,-0.0021,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 12 2018 09:10:30,30,6,2,1,0.5,0.755,0.826,0.885,2,0,0.7553,0.8262,0.8846,-0.1292,-0.2119,01一维
May 12 2018 09:10:36,21,21,58,29,0.49,0.406,0.484,0.8,4,1,0.5939,0.5162,0.2,0.394,0.3128,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 13 2018 08:22:59,30,1,2,6,3.14,0.959,0.903,0.903,4,1,0.041,0.0969,0.0969,-0.0559,-0.0077,01一维
May 15 2018 09:11:00,10,25,62,33,0.54,0.426,0.424,0.8,4,1,0.5743,0.5761,0.2,0.3744,0.2899,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:11:39,42,4,3,1,0.33,0.985,0.971,0.971,2,0,0.9853,0.9709,0.9709,0.0144,0.0282,完全背包模板
May 15 2018 09:12:20,18,24,63,32,0.51,0.481,0.435,0.8,3,1,0.5191,0.5646,0.2,0.3191,0.2295,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 15 2018 09:13:15,14,25,68,33,0.49,0.5,0.424,0.8,3,1,0.5,0.5759,0.2,0.3,0.21,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
May 15 2018 09:13:36,44,3,13,11,0.83,0.919,0.917,0.943,4,1,0.0806,0.0827,0.0568,0.0237,0.0033,线段树pushUp
May 15 2018 09:14:48,66,1,3,1,0.33,0.972,0.98,0.99,2,0,0.9718,0.9805,0.99,-0.0182,-0.0358,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:15:31,34,9,25,18,0.71,0.775,0.743,0.856,3,1,0.2247,0.257,0.1441,0.0806,0.0297,01二维
May 15 2018 09:16:23,12,4,27,35,1.29,0.99,0.987,0.987,3,1,0.0098,0.0126,0.0126,-0.0028,-0.0001,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:16:36,54,1,17,5,0.32,0.972,0.979,0.99,4,1,0.0281,0.021,0.01,0.0182,0.0007,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 15 2018 09:16:48,57,1,30,8,0.28,0.972,0.963,0.99,4,1,0.0283,0.0369,0.01,0.0184,0.0007,结点属性
May 15 2018 09:17:42,23,4,8,14,1.78,0.839,0.929,0.929,3,1,0.161,0.0715,0.0715,0.0896,0.0208,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 15 2018 09:18:23,27,4,23,15,0.67,0.983,0.971,0.971,3,1,0.0174,0.0291,0.0291,-0.0117,-0.0005,01二维
May 15 2018 09:18:41,60,1,3,1,0.33,0.971,0.963,0.99,2,0,0.9711,0.9631,0.99,-0.0189,-0.0371,黑高
May 15 2018 09:21:43,40,9,30,18,0.59,0.771,0.744,0.856,4,1,0.2288,0.2563,0.1441,0.0847,0.0316,完全背包模板
May 15 2018 09:22:24,38,9,20,18,0.88,0.774,0.743,0.856,3,1,0.2259,0.2566,0.1441,0.0818,0.0303,01一维
May 15 2018 09:22:52,35,9,40,18,0.44,0.777,0.743,0.856,4,1,0.2229,0.2571,0.1441,0.0788,0.0289,01二维
May 15 2018 09:23:32,20,24,63,32,0.51,0.542,0.435,0.8,4,1,0.458,0.5647,0.2,0.258,0.1697,状态压缩
May 15 2018 09:23:52,56,1,5,8,1.69,0.975,0.963,0.99,4,1,0.0253,0.0371,0.01,0.0153,0.0005,平衡性
May 15 2018 09:29:39,11,25,4,1,0.25,0.504,0.424,0.8,2,0,0.5036,0.4238,0.8,-0.2964,-0.3864,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:31:48,33,9,23,18,0.77,0.783,0.743,0.856,4,1,0.2165,0.2573,0.1441,0.0725,0.0261,01二维
May 15 2018 09:32:26,25,24,64,32,0.51,0.547,0.435,0.8,3,1,0.4527,0.5647,0.2,0.2527,0.165,状态压缩
May 15 2018 09:32:44,29,3,26,11,0.42,0.927,0.917,0.943,4,1,0.0727,0.0831,0.0568,0.0159,0.0021,线段树类型定义
May 15 2018 09:33:10,50,3,30,11,0.36,0.927,0.917,0.943,4,1,0.0728,0.0831,0.0568,0.0159,0.0021,线段树add
May 15 2018 09:33:38,41,4,9,14,1.59,0.839,0.928,0.928,4,1,0.161,0.0716,0.0716,0.0894,0.0208,完全背包模板
May 15 2018 09:34:08,58,1,32,8,0.27,0.975,0.963,0.99,4,1,0.0249,0.0373,0.01,0.015,0.0005,性质
May 15 2018 09:35:57,63,1,11,5,0.5,0.975,0.979,0.99,3,1,0.025,0.0214,0.01,0.015,0.0005,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 15 2018 09:36:29,36,9,4,1,0.25,0.787,0.743,0.856,2,0,0.7869,0.7431,0.8559,-0.0691,-0.1135,01一维
May 15 2018 09:36:59,24,24,3,1,0.33,0.504,0.435,0.8,2,0,0.504,0.4352,0.8,-0.296,-0.386,状态压缩
May 15 2018 09:37:22,59,1,9,9,0.95,0.972,0.963,0.99,4,1,0.0282,0.0374,0.01,0.0183,0.0007,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 15 2018 09:39:00,30,2,6,6,1.08,0.916,0.961,0.961,4,1,0.0841,0.0389,0.0389,0.0451,0.0056,01一维
May 15 2018 09:40:03,15,18,44,54,1.22,0.954,0.884,0.884,4,1,0.0464,0.1162,0.1162,-0.0698,-0.0113,*************************************************分割线. 单点更新. 当我们修改A[]数组中的某一个值时  应当如何更新C[]数组呢？. 回想一下 区间查询的过程，再看一下上文中列出的图. 结合代码分析. void add(int x_int y) . { . for(int .
May 15 2018 09:41:01,65,1,25,5,0.21,0.972,0.98,0.99,4,1,0.0283,0.0201,0.01,0.0184,0.0007,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:41:05,7,19,40,86,2.15,0.883,0.881,0.881,4,1,0.1167,0.1189,0.1189,-0.0022,-0.0005,树状数组彻底入门int lowbit(int t) . { . [.] . }. void add(int x_int y) . { . for(int i=x;i<=n;i+=lowbit(i)) . tree[i]+=y; . }. int getsum(int x) . { . int ans=0; . for(int i=x;i>0;i .
May 15 2018 09:42:34,16,20,51,57,1.11,0.929,0.864,0.864,4,1,0.0713,0.1364,0.1364,-0.0651,-0.0135,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
May 16 2018 06:53:11,66,1,2,6,2.81,0.97,0.909,0.909,3,1,0.0298,0.0906,0.0906,-0.0608,-0.0073,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 16 2018 06:53:33,60,1,2,6,2.8,0.971,0.91,0.91,4,1,0.029,0.0904,0.0904,-0.0614,-0.0073,黑高
May 16 2018 06:53:41,11,1,2,6,2.76,0.972,0.91,0.91,4,1,0.0282,0.0897,0.0897,-0.0615,-0.0072,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 16 2018 06:53:51,42,1,2,2,1.13,0.973,0.909,0.909,4,1,0.0274,0.0909,0.0909,-0.0635,-0.0075,完全背包模板
May 16 2018 06:54:07,36,1,2,5,2.74,0.973,0.911,0.911,4,1,0.0267,0.0892,0.0892,-0.0626,-0.0073,01一维
May 16 2018 06:54:15,24,1,2,5,2.74,0.974,0.911,0.911,5,1,0.026,0.0892,0.0892,-0.0632,-0.0073,状态压缩
May 18 2018 07:33:12,46,3,6,12,2.01,0.931,0.925,0.917,4,1,0.0694,0.0749,0.0832,-0.0138,-0.0021,线段树build
May 18 2018 07:34:04,47,3,6,12,2.01,0.93,0.925,0.917,4,1,0.0697,0.0749,0.0832,-0.0135,-0.0021,线段树search
May 18 2018 07:35:06,49,3,4,1,0.25,0.929,0.925,0.917,2,0,0.9289,0.925,0.9168,0.0121,0.0224,线段树pushDown
May 18 2018 07:35:31,31,3,4,1,0.25,0.927,0.925,0.917,2,0,0.9274,0.9246,0.9168,0.0106,0.0196,线段树updata
May 18 2018 07:35:54,42,2,4,5,1.13,0.943,0.903,0.903,4,1,0.0569,0.097,0.097,-0.0401,-0.0062,完全背包模板
May 19 2018 09:37:55,49,1,2,7,3.5,0.973,0.892,0.892,4,1,0.0266,0.1081,0.1081,-0.0815,-0.011,线段树pushDown
May 19 2018 09:38:08,31,1,2,7,3.5,0.974,0.892,0.892,3,1,0.026,0.108,0.108,-0.0821,-0.011,线段树updata
May 20 2018 07:34:52,84,3,5,12,2.48,0.931,0.91,0.917,3,1,0.0694,0.0896,0.0832,-0.0139,-0.0021,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
May 20 2018 07:36:08,79,2,4,7,1.65,0.953,0.954,0.943,4,1,0.047,0.0458,0.0568,-0.0098,-0.001,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:37:20,68,3,6,9,1.54,0.93,0.936,0.943,4,1,0.07,0.0636,0.0568,0.0131,0.0017,1
May 20 2018 07:37:39,62,3,4,1,0.25,0.929,0.936,0.943,2,0,0.9285,0.9364,0.9432,-0.0147,-0.0274,2
May 20 2018 07:38:08,19,3,6,9,1.51,0.928,0.938,0.943,4,1,0.0717,0.0622,0.0568,0.0149,0.0019,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:39:11,63,3,5,23,4.64,0.928,0.994,0.943,3,1,0.072,0.0062,0.0568,0.0151,0.0019,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 20 2018 07:40:50,65,5,4,1,0.25,0.823,0.964,0.964,2,0,0.8227,0.9638,0.9638,-0.141,-0.2519,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 20 2018 07:40:59,54,5,12,15,1.26,0.823,0.964,0.964,4,1,0.1773,0.0363,0.0363,0.141,0.0301,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 20 2018 07:42:15,69,3,5,9,1.85,0.928,0.936,0.943,3,1,0.0721,0.0637,0.0568,0.0153,0.002,3
May 20 2018 07:42:29,45,3,6,9,1.53,0.928,0.937,0.943,4,1,0.0724,0.0631,0.0568,0.0155,0.002,4
May 20 2018 07:42:55,21,4,9,18,2.05,0.907,0.885,0.917,4,1,0.0927,0.1147,0.0832,0.0095,0.0017,红黑树旋转
May 21 2018 07:01:51,30,6,11,29,2.6,0.86,0.928,0.928,4,1,0.1397,0.0721,0.0721,0.0676,0.0143,01一维
May 21 2018 07:02:20,65,1,2,3,1.25,0.974,0.903,0.903,4,1,0.0259,0.0975,0.0975,-0.0716,-0.0088,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 21 2018 07:02:35,36,5,12,22,1.8,0.803,0.903,0.903,4,1,0.1971,0.0968,0.0968,0.1003,0.0295,01一维
May 21 2018 07:02:42,24,5,12,22,1.8,0.823,0.903,0.903,4,1,0.1773,0.0968,0.0968,0.0805,0.0221,状态压缩
May 21 2018 07:03:24,62,1,2,6,3.19,0.975,0.902,0.902,4,1,0.0254,0.0977,0.0977,-0.0724,-0.0089,2
May 22 2018 08:29:45,66,6,15,24,1.62,0.74,0.885,0.885,4,1,0.2599,0.1151,0.1151,0.1449,0.0543,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 22 2018 08:30:03,60,6,10,24,2.42,0.74,0.885,0.885,3,1,0.2599,0.1152,0.1152,0.1447,0.0543,黑高
May 22 2018 08:30:18,11,6,16,24,1.51,0.768,0.884,0.884,4,1,0.2316,0.1157,0.1157,0.1158,0.0402,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 23 2018 06:47:21,57,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2122,0.0688,结点属性
May 23 2018 06:47:51,58,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0558,0.0558,0.2123,0.0688,性质
May 23 2018 06:48:18,42,5,10,7,0.74,0.907,0.84,0.84,4,1,0.0929,0.1598,0.1598,-0.0669,-0.0169,完全背包模板
May 23 2018 06:48:26,56,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2123,0.0688,平衡性
May 24 2018 07:25:49,65,3,6,6,0.93,0.877,0.863,0.863,4,1,0.1234,0.1367,0.1367,-0.0133,-0.0035,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 24 2018 07:25:56,59,9,24,25,1.06,0.704,0.937,0.937,4,1,0.2962,0.0629,0.0629,0.2333,0.0838,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 26 2018 07:20:17,50,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树add
May 26 2018 07:20:31,31,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树updata
May 26 2018 07:20:51,44,11,25,34,1.35,0.879,0.923,0.923,4,1,0.1208,0.0765,0.0765,0.0443,0.0087,线段树pushUp
May 26 2018 07:20:59,29,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树类型定义
May 26 2018 07:21:26,49,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树pushDown
May 27 2018 07:33:23,79,7,4,1,0.25,0.872,0.894,0.894,2,0,0.8723,0.8943,0.8943,-0.022,-0.0388,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 27 2018 07:34:38,83,11,4,1,0.25,0.747,0.693,0.843,2,0,0.7468,0.6925,0.8427,-0.0958,-0.1524,删除替换点
May 27 2018 07:35:39,62,6,15,24,1.62,0.74,0.891,0.891,4,1,0.2599,0.1093,0.1093,0.1506,0.0556,2
May 28 2018 10:13:26,79,1,2,1,0.5,0.954,0.89,0.89,2,0,0.9539,0.8895,0.8895,0.0644,0.1187,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 28 2018 10:13:59,83,1,2,7,3.55,0.954,0.89,0.89,3,1,0.0457,0.1104,0.1104,-0.0647,-0.0101,删除替换点
May 28 2018 10:14:35,34,13,2,1,0.5,0.945,0.929,0.929,2,0,0.9454,0.9295,0.9295,0.0159,0.0298,01二维
May 28 2018 10:15:18,35,13,30,35,1.17,0.968,0.93,0.93,4,1,0.0321,0.0705,0.0705,-0.0384,-0.0039,01二维
May 29 2018 09:17:55,18,13,45,20,0.45,0.571,0.644,0.827,4,1,0.4289,0.3563,0.1727,0.2562,0.1541,删除1
May 29 2018 09:18:13,41,14,31,59,1.9,0.822,0.919,0.919,4,1,0.1784,0.0811,0.0811,0.0974,0.0253,完全背包模板
May 29 2018 09:18:25,34,1,2,2,1.23,0.956,0.904,0.904,4,1,0.0442,0.0963,0.0963,-0.0521,-0.0073,01二维
May 29 2018 09:19:29,68,9,14,33,2.36,0.894,0.891,0.891,3,1,0.1063,0.1091,0.1091,-0.0028,-0.0006,1
May 29 2018 09:20:32,19,9,19,33,1.74,0.894,0.89,0.89,4,1,0.1063,0.1098,0.1098,-0.0035,-0.0008,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 29 2018 09:21:13,23,14,24,59,2.46,0.762,0.919,0.919,4,1,0.2382,0.0813,0.0813,0.1568,0.0501,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 29 2018 09:21:54,69,9,2,1,0.5,0.82,0.891,0.891,2,0,0.8202,0.891,0.891,-0.0708,-0.1211,3
May 29 2018 09:22:27,45,9,2,1,0.5,0.893,0.891,0.891,2,0,0.8931,0.8907,0.8907,0.0024,0.0042,4
May 29 2018 09:23:25,79,1,2,1,0.5,0.952,0.903,0.903,2,0,0.9521,0.9033,0.9033,0.0488,0.0906,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 08:59:26,82,3,6,12,2.08,0.877,0.923,0.917,3,1,0.1228,0.0772,0.0832,0.0395,0.0081,找到替换点
May 30 2018 09:00:06,69,1,2,1,0.5,0.95,0.901,0.901,2,0,0.9498,0.9014,0.9014,0.0484,0.0895,3
May 30 2018 09:00:22,79,1,2,3,1.27,0.948,0.902,0.902,4,1,0.052,0.0985,0.0985,-0.0465,-0.007,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 09:00:42,45,1,2,3,1.27,0.953,0.901,0.901,4,1,0.0475,0.0986,0.0986,-0.0511,-0.0075,4
May 30 2018 09:01:24,46,12,29,39,1.34,0.833,0.865,0.865,4,1,0.1668,0.135,0.135,0.0318,0.0096,线段树build
May 30 2018 09:02:19,65,6,11,9,0.8,0.925,0.842,0.842,4,1,0.0751,0.1577,0.1577,-0.0827,-0.0192,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 30 2018 09:02:41,47,12,30,39,1.29,0.837,0.865,0.865,4,1,0.1632,0.135,0.135,0.0282,0.0084,线段树search
May 30 2018 09:03:03,27,15,35,73,2.08,0.849,0.891,0.891,4,1,0.151,0.109,0.109,0.042,0.0109,01二维
May 31 2018 12:19:29,66,9,17,31,1.85,0.96,0.955,0.955,3,1,0.0398,0.0453,0.0453,-0.0055,-0.0005,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 31 2018 12:19:52,34,2,4,5,1.19,0.916,0.901,0.901,4,1,0.0841,0.0989,0.0989,-0.0149,-0.0027,01二维
May 31 2018 12:20:04,60,9,13,31,2.42,0.901,0.955,0.955,4,1,0.0991,0.0453,0.0453,0.0537,0.0078,黑高
May 31 2018 12:20:24,69,1,2,3,1.39,0.95,0.887,0.887,4,1,0.0502,0.1131,0.1131,-0.0629,-0.0103,3
May 31 2018 12:21:19,42,8,13,11,0.82,0.931,0.832,0.832,4,1,0.0685,0.1683,0.1683,-0.0997,-0.0236,完全背包模板
May 31 2018 12:21:23,11,9,18,31,1.75,0.963,0.955,0.955,4,1,0.0369,0.0454,0.0454,-0.0085,-0.0007,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 01 2018 09:08:12,84,12,23,37,1.63,0.769,0.916,0.916,4,1,0.2313,0.0842,0.0842,0.1472,0.0464,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Jun 01 2018 09:08:48,9,15,49,23,0.46,0.509,0.596,0.819,4,1,0.4913,0.404,0.1809,0.3104,0.2087,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:33,79,3,4,6,1.39,0.877,0.865,0.865,3,1,0.1234,0.1351,0.1351,-0.0117,-0.003,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:57,33,18,39,55,1.41,0.951,0.904,0.904,4,1,0.049,0.0958,0.0958,-0.0467,-0.0068,01二维
Jun 02 2018 08:50:10,38,18,32,55,1.72,0.896,0.904,0.904,4,1,0.1043,0.0961,0.0961,0.0082,0.0016,01一维
Jun 02 2018 08:50:34,45,3,6,6,0.93,0.877,0.865,0.865,4,1,0.1234,0.135,0.135,-0.0116,-0.003,4
Jun 02 2018 08:51:00,40,18,43,55,1.28,0.955,0.904,0.904,4,1,0.0447,0.0962,0.0962,-0.0515,-0.0073,完全背包模板
Jun 03 2018 08:28:45,69,3,6,6,0.94,0.877,0.881,0.881,4,1,0.1234,0.119,0.119,0.0044,0.0011,3
Jun 04 2018 07:51:24,117,1,2,1,0.5,0.956,0.969,0.99,2,0,0.9559,0.9685,0.99,-0.0342,-0.0665,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 04 2018 07:52:50,93,2,4,8,2,0.914,0.934,0.943,4,1,0.0861,0.0664,0.0568,0.0292,0.0042,图割点
Jun 04 2018 07:53:15,100,2,4,7,1.86,0.914,0.936,0.943,4,1,0.0858,0.0637,0.0568,0.029,0.0041,修改距离动态规划
Jun 04 2018 07:53:30,54,15,27,67,2.48,0.896,0.911,0.911,3,1,0.104,0.0894,0.0894,0.0146,0.0028,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Jun 04 2018 07:55:00,83,7,18,27,1.49,0.715,0.886,0.886,4,1,0.2847,0.1137,0.1137,0.171,0.0681,删除替换点
Jun 05 2018 17:21:07,129,2,5,9,1.72,0.914,0.929,0.943,4,1,0.0856,0.0706,0.0568,0.0288,0.0041,有向图求欧拉回路：. [.]
Jun 05 2018 17:21:32,34,5,10,8,0.76,0.896,0.836,0.836,4,1,0.1039,0.1636,0.1636,-0.0597,-0.016,01二维
Jun 05 2018 17:22:00,119,2,4,10,2.47,0.915,0.922,0.943,3,1,0.0853,0.0778,0.0568,0.0285,0.004,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 05 2018 17:22:36,91,17,56,25,0.44,0.483,0.553,0.812,4,1,0.5169,0.4471,0.1881,0.3288,0.2318,KMP算法
Jun 05 2018 17:23:29,117,1,2,8,4.03,0.955,0.863,0.863,4,1,0.0446,0.1369,0.1369,-0.0923,-0.0167,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 05 2018 17:23:55,103,3,7,13,1.92,0.879,0.905,0.917,4,1,0.121,0.0946,0.0832,0.0378,0.0077,快速幂
Jun 05 2018 17:24:16,49,10,21,35,1.68,0.962,0.953,0.953,4,1,0.0383,0.0473,0.0473,-0.009,-0.0008,线段树pushDown
Jun 05 2018 17:24:45,80,3,6,18,2.93,0.879,0.889,0.917,3,1,0.1206,0.1106,0.0832,0.0373,0.0076,什么是错排公式？
Jun 05 2018 17:25:26,16,3,7,25,3.59,0.88,0.994,0.917,4,1,0.1202,0.0064,0.0832,0.0369,0.0075,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Jun 06 2018 08:27:47,124,3,7,11,1.56,0.88,0.932,0.917,4,1,0.1197,0.0679,0.0832,0.0365,0.0074,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 06 2018 08:28:25,133,3,2,1,0.5,0.879,0.91,0.917,2,0,0.8791,0.9097,0.9168,-0.0376,-0.0676,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 06 2018 08:28:35,77,3,7,14,2.03,0.88,0.902,0.917,4,1,0.1204,0.098,0.0832,0.0372,0.0076,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G[.]. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 06 2018 08:28:56,125,3,7,11,1.56,0.88,0.932,0.917,4,1,0.12,0.0679,0.0832,0.0368,0.0075,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 06 2018 08:29:08,123,3,2,1,0.5,0.879,0.932,0.917,1,0,0.8787,0.932,0.9168,-0.038,-0.0683,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 06 2018 08:29:26,122,3,2,1,0.5,0.878,0.932,0.917,1,0,0.8775,0.932,0.9168,-0.0393,-0.0704,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 07 2018 08:49:36,128,4,11,19,1.7,0.841,0.877,0.898,4,1,0.1589,0.1228,0.1015,0.0574,0.015,无向图求欧拉回路. [.]
Jun 07 2018 08:50:03,123,1,1,7,6.69,0.955,0.899,0.899,3,1,0.0451,0.1014,0.1014,-0.0563,-0.0082,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 07 2018 08:50:36,85,21,65,29,0.44,0.421,0.483,0.8,4,1,0.5792,0.5171,0.2,0.3792,0.2955,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 07 2018 08:51:05,21,18,42,54,1.29,0.808,0.877,0.877,4,1,0.1918,0.1232,0.1232,0.0685,0.0216,红黑树旋转
Jun 07 2018 08:52:29,122,1,2,7,3.35,0.957,0.898,0.898,4,1,0.0427,0.1015,0.1015,-0.0588,-0.0085,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 08 2018 09:14:52,90,1,2,5,2.69,0.96,0.979,0.99,4,1,0.0402,0.0208,0.01,0.0302,0.0015,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jun 08 2018 09:15:46,65,9,13,12,0.92,0.924,0.839,0.839,3,1,0.076,0.1611,0.1611,-0.0851,-0.0202,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 08 2018 09:17:19,45,6,10,9,0.88,0.932,0.843,0.843,3,1,0.0678,0.1569,0.1569,-0.089,-0.02,4
Jun 08 2018 09:17:43,79,6,8,9,1.1,0.877,0.843,0.843,3,1,0.1225,0.1569,0.1569,-0.0344,-0.0096,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 08 2018 09:19:04,139,1,2,5,2.69,0.96,0.979,0.99,4,1,0.0401,0.0209,0.01,0.0301,0.0015,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jun 08 2018 09:21:12,115,5,14,22,1.56,0.816,0.84,0.885,4,1,0.184,0.1604,0.1154,0.0686,0.0205,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Jun 09 2018 10:17:00,132,3,5,13,2.51,0.885,0.922,0.917,3,1,0.1145,0.0776,0.0832,0.0313,0.0062,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 09 2018 10:17:44,133,3,2,1,0.5,0.884,0.628,0.917,2,0,0.8842,0.6285,0.9168,-0.0325,-0.0586,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 09 2018 10:18:23,69,6,11,9,0.79,0.925,0.84,0.84,4,1,0.0751,0.1602,0.1602,-0.0851,-0.02,3
Jun 09 2018 10:19:08,73,23,67,31,0.47,0.409,0.449,0.8,4,1,0.5913,0.5508,0.2,0.3914,0.3097,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 10 2018 09:58:36,133,1,2,6,3.24,0.959,0.901,0.901,4,1,0.0406,0.0987,0.0987,-0.0582,-0.0081,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 10 2018 09:59:03,50,15,26,51,1.94,0.948,0.953,0.953,4,1,0.0521,0.0468,0.0468,0.0053,0.0005,线段树add
Jun 11 2018 10:21:05,82,12,27,39,1.44,0.822,0.867,0.867,4,1,0.1781,0.1333,0.1333,0.0447,0.0139,找到替换点
Jun 11 2018 10:21:40,62,15,33,58,1.76,0.928,0.927,0.927,4,1,0.0724,0.073,0.073,-0.0005,-0.0001,2
Jun 12 2018 21:46:29,116,9,31,18,0.58,0.708,0.717,0.849,4,1,0.2919,0.2835,0.1511,0.1408,0.0624,2.定理：. 1.[.]充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 13 2018 16:14:14,90,5,13,14,1.1,0.839,0.961,0.961,4,1,0.161,0.0389,0.0389,0.1222,0.0244,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jun 13 2018 16:14:33,93,9,17,29,1.71,0.866,0.934,0.934,3,1,0.1338,0.0659,0.0659,0.068,0.0136,图割点
Jun 13 2018 16:15:17,101,3,5,13,2.63,0.892,0.919,0.917,3,1,0.1084,0.0813,0.0832,0.0251,0.0048,修改距离动态规划
Jun 13 2018 16:15:27,16,8,23,27,1.16,0.925,0.968,0.968,5,1,0.0751,0.0321,0.0321,0.043,0.0046,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Jun 13 2018 16:15:52,117,8,17,30,1.74,0.626,0.885,0.885,4,1,0.3738,0.1147,0.1147,0.2591,0.1266,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 13 2018 16:16:06,34,8,14,11,0.77,0.938,0.839,0.839,4,1,0.0621,0.1609,0.1609,-0.0988,-0.022,01二维
Jun 13 2018 16:16:30,36,23,2,1,0.5,0.8,0.881,0.881,2,0,0.8005,0.8808,0.8808,-0.0803,-0.1351,01一维
Jun 13 2018 16:16:34,24,23,47,100,2.12,0.795,0.881,0.881,4,1,0.2048,0.1192,0.1192,0.0856,0.0277,状态压缩
Jun 13 2018 16:17:27,31,18,37,73,1.97,0.915,0.918,0.918,4,1,0.0851,0.0819,0.0819,0.0032,0.0005,线段树updata
Jun 13 2018 16:18:42,100,3,3,1,0.33,0.89,0.992,0.917,2,0,0.8905,0.9921,0.9168,-0.0263,-0.0475,修改距离动态规划
Jun 13 2018 16:19:06,139,3,7,23,3.27,0.891,0.992,0.917,4,1,0.1091,0.0079,0.0832,0.0259,0.005,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jun 13 2018 16:19:55,63,24,38,105,2.76,0.546,0.897,0.897,4,1,0.4538,0.1029,0.1029,0.3509,0.1954,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
Jun 13 2018 16:22:23,42,13,20,23,1.16,0.901,0.862,0.862,4,1,0.0988,0.1378,0.1378,-0.039,-0.0092,完全背包模板
Jun 16 2018 09:15:20,129,11,3,1,0.33,0.846,0.925,0.925,2,0,0.8461,0.9252,0.9252,-0.0791,-0.1402,有向图求欧拉回路：. [.]
Jun 16 2018 09:16:17,133,6,14,24,1.73,0.736,0.892,0.892,4,1,0.2642,0.1078,0.1078,0.1564,0.0582,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 16 2018 09:16:25,56,24,55,100,1.82,0.898,0.913,0.913,4,1,0.102,0.0871,0.0871,0.0149,0.0028,平衡性
Jun 16 2018 09:16:38,36,3,6,2,0.41,0.876,0.752,0.752,4,1,0.1242,0.2483,0.2483,-0.124,-0.0462,01一维
Jun 16 2018 09:16:46,122,9,17,29,1.7,0.549,0.846,0.846,4,1,0.4512,0.1542,0.1542,0.297,0.1798,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 16 2018 09:17:28,57,24,56,100,1.79,0.898,0.913,0.913,4,1,0.1021,0.087,0.087,0.015,0.0028,结点属性
Jun 16 2018 09:17:48,47,17,50,57,1.14,0.964,0.945,0.945,5,1,0.0361,0.0552,0.0552,-0.0192,-0.0017,线段树search
Jun 16 2018 09:17:58,119,11,22,33,1.5,0.715,0.925,0.925,4,1,0.2845,0.0748,0.0748,0.2098,0.0754,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 16 2018 09:18:08,123,9,16,29,1.81,0.507,0.846,0.846,4,1,0.4932,0.1544,0.1544,0.3387,0.2194,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 16 2018 09:18:32,100,3,5,2,0.49,0.89,0.752,0.752,4,1,0.1104,0.2482,0.2482,-0.1378,-0.0494,修改距离动态规划
Jun 16 2018 09:18:44,25,32,75,89,1.18,0.97,0.91,0.91,4,1,0.0298,0.0903,0.0903,-0.0605,-0.0073,状态压缩
Jun 16 2018 09:19:31,95,14,2,1,0.5,0.564,0.611,0.823,2,0,0.5643,0.6112,0.8231,-0.2588,-0.359,图割点
Jun 16 2018 09:19:43,46,17,35,57,1.62,0.963,0.945,0.945,4,1,0.0367,0.0552,0.0552,-0.0186,-0.0017,线段树build
Jun 16 2018 09:20:04,58,24,43,100,2.33,0.897,0.913,0.913,3,1,0.1025,0.0872,0.0872,0.0153,0.0029,性质
Jun 16 2018 09:20:20,20,32,76,89,1.17,0.969,0.91,0.91,4,1,0.0306,0.0903,0.0903,-0.0598,-0.0072,状态压缩
Jun 17 2018 17:40:01,124,11,26,40,1.52,0.893,0.896,0.896,4,1,0.1068,0.1041,0.1041,0.0026,0.0006,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 17 2018 17:40:33,79,9,13,23,1.76,0.882,0.935,0.935,4,1,0.1178,0.0647,0.0647,0.0531,0.0097,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 18 2018 16:57:23,129,2,4,3,0.67,0.919,0.783,0.783,4,1,0.0815,0.2169,0.2169,-0.1354,-0.0404,有向图求欧拉回路：. [.]
Jun 18 2018 16:57:51,125,12,2,1,0.5,0.882,0.888,0.888,2,0,0.8818,0.8875,0.8875,-0.0057,-0.0101,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 18 2018 16:58:58,103,13,36,30,0.83,0.869,0.954,0.954,4,1,0.131,0.0459,0.0459,0.0851,0.0151,快速幂
Jun 18 2018 16:59:14,128,11,26,30,1.16,0.933,0.96,0.96,4,1,0.0667,0.0402,0.0402,0.0265,0.0028,无向图求欧拉回路. [.]
Jun 18 2018 16:59:24,108,15,51,15,0.29,0.557,0.584,0.584,4,1,0.4428,0.416,0.416,0.0269,0.0231,AVL
Jun 18 2018 16:59:45,95,2,4,7,1.64,0.922,0.783,0.783,4,1,0.0783,0.2168,0.2168,-0.1386,-0.0409,图割点
Jun 18 2018 17:01:03,19,20,3,1,0.33,0.897,0.95,0.95,2,0,0.8973,0.9498,0.9498,-0.0525,-0.0969,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 18 2018 17:01:57,45,10,13,18,1.38,0.893,0.903,0.924,3,1,0.1065,0.0967,0.0763,0.0302,0.0055,4
Jun 18 2018 17:02:06,18,20,54,47,0.88,0.974,0.937,0.949,4,1,0.026,0.063,0.0512,-0.0252,-0.0019,删除1
Jun 18 2018 17:02:13,59,25,59,93,1.58,0.907,0.932,0.955,4,1,0.0925,0.0677,0.0449,0.0476,0.0065,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
Jun 18 2018 17:02:19,10,34,80,69,0.86,0.969,0.948,0.948,4,1,0.0306,0.0521,0.0521,-0.0214,-0.0018,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 18 2018 17:02:36,14,34,80,69,0.86,0.969,0.948,0.948,4,1,0.0306,0.0521,0.0521,-0.0215,-0.0018,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
Jun 18 2018 17:03:32,69,9,2,1,0.5,0.926,0.919,0.947,2,0,0.9263,0.9191,0.9467,-0.0204,-0.0383,3
Jun 18 2018 17:05:18,66,18,33,62,1.89,0.887,0.935,0.935,4,1,0.1132,0.0646,0.0646,0.0487,0.0087,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 19 2018 09:41:45,125,1,2,2,0.8,0.96,0.929,0.944,4,1,0.0398,0.0708,0.0562,-0.0164,-0.0016,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 19 2018 09:42:14,30,29,49,134,2.73,0.701,0.882,0.923,4,1,0.2991,0.118,0.0769,0.2222,0.0835,01一维
Jun 19 2018 09:42:35,89,33,93,25,0.27,0.3,0.463,0.463,4,1,0.6997,0.5368,0.5368,0.1629,0.2014,typedef struct RBtree. {. [红黑树的结构定义]. } rbtree;
Jun 19 2018 09:43:28,69,1,2,2,0.79,0.957,0.929,0.953,4,1,0.0431,0.0705,0.0467,-0.0036,-0.0003,3
Jun 19 2018 09:45:06,12,35,62,98,1.58,0.553,0.948,0.965,4,1,0.4466,0.052,0.0349,0.4117,0.1983,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 19 2018 09:46:05,19,1,2,2,0.8,0.962,0.929,0.96,4,1,0.0376,0.0709,0.0405,-0.0029,-0.0002,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 20 2018 06:37:43,77,14,39,42,1.09,0.862,0.956,0.97,4,1,0.1384,0.0437,0.0296,0.1088,0.0183,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G[.]. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 21 2018 18:03:31,125,2,4,4,1.07,0.925,0.933,0.947,4,1,0.0751,0.0668,0.053,0.022,0.0028,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 21 2018 18:03:48,100,5,8,10,1.31,0.929,0.871,0.899,4,1,0.0706,0.1287,0.1012,-0.0307,-0.0053,修改距离动态规划
Jun 21 2018 18:04:12,19,2,3,5,1.72,0.916,0.901,0.935,3,1,0.0841,0.0992,0.065,0.0191,0.0028,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 21 2018 18:04:56,65,13,20,24,1.2,0.894,0.923,0.923,4,1,0.106,0.077,0.077,0.029,0.0053,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 21 2018 18:05:09,36,5,9,12,1.35,0.937,0.872,0.929,4,1,0.063,0.1283,0.0714,-0.0084,-0.0011,01一维
Jun 21 2018 18:05:31,69,2,4,7,1.79,0.916,0.941,0.97,4,1,0.0841,0.0593,0.0303,0.0537,0.0061,3
Jun 21 2018 18:08:29,146,1,16,33,2.06,0.965,0.996,0.995,4,1,0.0352,0.0042,0.0045,0.0307,0.0012,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
