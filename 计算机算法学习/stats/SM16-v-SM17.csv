Date, Element No, Used interval, SM16 Interval (new), SM17 Interval (new), SM17/SM16 Interval ratio, R (SM16), R (SM17)(exp), R (SM17), Grade, Success, abs RM16, abs RM17 (expected), abs RM17 (predicted), abs R-Metric, sqr R-Metric, Title,
May 10 2018 07:03:01,41,4,2,1,0.5,0.817,0.889,0.917,2,0,0.8171,0.8894,0.9168,-0.0996,-0.1727,完全背包模板
May 10 2018 07:03:21,23,19,2,1,0.5,0.288,0.521,0.806,1,0,0.2884,0.5207,0.8056,-0.5172,-0.5659,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:04,42,5,17,22,1.28,0.714,0.858,0.898,4,1,0.2855,0.1424,0.1015,0.184,0.0712,完全背包模板
May 11 2018 08:00:25,41,1,2,7,3.4,0.951,0.896,0.896,4,1,0.0489,0.1038,0.1038,-0.0549,-0.0084,完全背包模板
May 11 2018 08:00:33,23,1,2,7,3.4,0.956,0.896,0.896,4,1,0.0444,0.1038,0.1038,-0.0594,-0.0088,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:50,27,5,15,22,1.46,0.799,0.857,0.898,4,1,0.2013,0.1433,0.1015,0.0998,0.0302,01二维
May 11 2018 08:01:07,12,11,28,26,0.92,0.98,0.95,0.95,4,1,0.0201,0.0503,0.0503,-0.0301,-0.0021,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 12 2018 09:10:30,30,6,2,1,0.5,0.755,0.826,0.885,2,0,0.7553,0.8262,0.8846,-0.1292,-0.2119,01一维
May 12 2018 09:10:36,21,21,58,29,0.49,0.406,0.484,0.8,4,1,0.5939,0.5162,0.2,0.394,0.3128,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 13 2018 08:22:59,30,1,2,6,3.14,0.959,0.903,0.903,4,1,0.041,0.0969,0.0969,-0.0559,-0.0077,01一维
May 15 2018 09:11:00,10,25,62,33,0.54,0.426,0.424,0.8,4,1,0.5743,0.5761,0.2,0.3744,0.2899,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:11:39,42,4,3,1,0.33,0.985,0.971,0.971,2,0,0.9853,0.9709,0.9709,0.0144,0.0282,完全背包模板
May 15 2018 09:12:20,18,24,63,32,0.51,0.481,0.435,0.8,3,1,0.5191,0.5646,0.2,0.3191,0.2295,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 15 2018 09:13:15,14,25,68,33,0.49,0.5,0.424,0.8,3,1,0.5,0.5759,0.2,0.3,0.21,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
May 15 2018 09:13:36,44,3,13,11,0.83,0.919,0.917,0.943,4,1,0.0806,0.0827,0.0568,0.0237,0.0033,线段树pushUp
May 15 2018 09:14:48,66,1,3,1,0.33,0.972,0.98,0.99,2,0,0.9718,0.9805,0.99,-0.0182,-0.0358,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:15:31,34,9,25,18,0.71,0.775,0.743,0.856,3,1,0.2247,0.257,0.1441,0.0806,0.0297,01二维
May 15 2018 09:16:23,12,4,27,35,1.29,0.99,0.987,0.987,3,1,0.0098,0.0126,0.0126,-0.0028,-0.0001,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:16:36,54,1,17,5,0.32,0.972,0.979,0.99,4,1,0.0281,0.021,0.01,0.0182,0.0007,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 15 2018 09:16:48,57,1,30,8,0.28,0.972,0.963,0.99,4,1,0.0283,0.0369,0.01,0.0184,0.0007,结点属性
May 15 2018 09:17:42,23,4,8,14,1.78,0.839,0.929,0.929,3,1,0.161,0.0715,0.0715,0.0896,0.0208,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 15 2018 09:18:23,27,4,23,15,0.67,0.983,0.971,0.971,3,1,0.0174,0.0291,0.0291,-0.0117,-0.0005,01二维
May 15 2018 09:18:41,60,1,3,1,0.33,0.971,0.963,0.99,2,0,0.9711,0.9631,0.99,-0.0189,-0.0371,黑高
May 15 2018 09:21:43,40,9,30,18,0.59,0.771,0.744,0.856,4,1,0.2288,0.2563,0.1441,0.0847,0.0316,完全背包模板
May 15 2018 09:22:24,38,9,20,18,0.88,0.774,0.743,0.856,3,1,0.2259,0.2566,0.1441,0.0818,0.0303,01一维
May 15 2018 09:22:52,35,9,40,18,0.44,0.777,0.743,0.856,4,1,0.2229,0.2571,0.1441,0.0788,0.0289,01二维
May 15 2018 09:23:32,20,24,63,32,0.51,0.542,0.435,0.8,4,1,0.458,0.5647,0.2,0.258,0.1697,状态压缩
May 15 2018 09:23:52,56,1,5,8,1.69,0.975,0.963,0.99,4,1,0.0253,0.0371,0.01,0.0153,0.0005,平衡性
May 15 2018 09:29:39,11,25,4,1,0.25,0.504,0.424,0.8,2,0,0.5036,0.4238,0.8,-0.2964,-0.3864,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:31:48,33,9,23,18,0.77,0.783,0.743,0.856,4,1,0.2165,0.2573,0.1441,0.0725,0.0261,01二维
May 15 2018 09:32:26,25,24,64,32,0.51,0.547,0.435,0.8,3,1,0.4527,0.5647,0.2,0.2527,0.165,状态压缩
May 15 2018 09:32:44,29,3,26,11,0.42,0.927,0.917,0.943,4,1,0.0727,0.0831,0.0568,0.0159,0.0021,线段树类型定义
May 15 2018 09:33:10,50,3,30,11,0.36,0.927,0.917,0.943,4,1,0.0728,0.0831,0.0568,0.0159,0.0021,线段树add
May 15 2018 09:33:38,41,4,9,14,1.59,0.839,0.928,0.928,4,1,0.161,0.0716,0.0716,0.0894,0.0208,完全背包模板
May 15 2018 09:34:08,58,1,32,8,0.27,0.975,0.963,0.99,4,1,0.0249,0.0373,0.01,0.015,0.0005,性质
May 15 2018 09:35:57,63,1,11,5,0.5,0.975,0.979,0.99,3,1,0.025,0.0214,0.01,0.015,0.0005,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 15 2018 09:36:29,36,9,4,1,0.25,0.787,0.743,0.856,2,0,0.7869,0.7431,0.8559,-0.0691,-0.1135,01一维
May 15 2018 09:36:59,24,24,3,1,0.33,0.504,0.435,0.8,2,0,0.504,0.4352,0.8,-0.296,-0.386,状态压缩
May 15 2018 09:37:22,59,1,9,9,0.95,0.972,0.963,0.99,4,1,0.0282,0.0374,0.01,0.0183,0.0007,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 15 2018 09:39:00,30,2,6,6,1.08,0.916,0.961,0.961,4,1,0.0841,0.0389,0.0389,0.0451,0.0056,01一维
May 15 2018 09:40:03,15,18,44,54,1.22,0.954,0.884,0.884,4,1,0.0464,0.1162,0.1162,-0.0698,-0.0113,*************************************************分割线. 单点更新. 当我们修改A[]数组中的某一个值时  应当如何更新C[]数组呢？. 回想一下 区间查询的过程，再看一下上文中列出的图. 结合代码分析. void add(int x_int y) . { . for(int .
May 15 2018 09:41:01,65,1,25,5,0.21,0.972,0.98,0.99,4,1,0.0283,0.0201,0.01,0.0184,0.0007,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:41:05,7,19,40,86,2.15,0.883,0.881,0.881,4,1,0.1167,0.1189,0.1189,-0.0022,-0.0005,树状数组彻底入门int lowbit(int t) . { . [.] . }. void add(int x_int y) . { . for(int i=x;i<=n;i+=lowbit(i)) . tree[i]+=y; . }. int getsum(int x) . { . int ans=0; . for(int i=x;i>0;i .
May 15 2018 09:42:34,16,20,51,57,1.11,0.929,0.864,0.864,4,1,0.0713,0.1364,0.1364,-0.0651,-0.0135,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
May 16 2018 06:53:11,66,1,2,6,2.81,0.97,0.909,0.909,3,1,0.0298,0.0906,0.0906,-0.0608,-0.0073,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 16 2018 06:53:33,60,1,2,6,2.8,0.971,0.91,0.91,4,1,0.029,0.0904,0.0904,-0.0614,-0.0073,黑高
May 16 2018 06:53:41,11,1,2,6,2.76,0.972,0.91,0.91,4,1,0.0282,0.0897,0.0897,-0.0615,-0.0072,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 16 2018 06:53:51,42,1,2,2,1.13,0.973,0.909,0.909,4,1,0.0274,0.0909,0.0909,-0.0635,-0.0075,完全背包模板
May 16 2018 06:54:07,36,1,2,5,2.74,0.973,0.911,0.911,4,1,0.0267,0.0892,0.0892,-0.0626,-0.0073,01一维
May 16 2018 06:54:15,24,1,2,5,2.74,0.974,0.911,0.911,5,1,0.026,0.0892,0.0892,-0.0632,-0.0073,状态压缩
May 18 2018 07:33:12,46,3,6,12,2.01,0.931,0.925,0.917,4,1,0.0694,0.0749,0.0832,-0.0138,-0.0021,线段树build
May 18 2018 07:34:04,47,3,6,12,2.01,0.93,0.925,0.917,4,1,0.0697,0.0749,0.0832,-0.0135,-0.0021,线段树search
May 18 2018 07:35:06,49,3,4,1,0.25,0.929,0.925,0.917,2,0,0.9289,0.925,0.9168,0.0121,0.0224,线段树pushDown
May 18 2018 07:35:31,31,3,4,1,0.25,0.927,0.925,0.917,2,0,0.9274,0.9246,0.9168,0.0106,0.0196,线段树updata
May 18 2018 07:35:54,42,2,4,5,1.13,0.943,0.903,0.903,4,1,0.0569,0.097,0.097,-0.0401,-0.0062,完全背包模板
May 19 2018 09:37:55,49,1,2,7,3.5,0.973,0.892,0.892,4,1,0.0266,0.1081,0.1081,-0.0815,-0.011,线段树pushDown
May 19 2018 09:38:08,31,1,2,7,3.5,0.974,0.892,0.892,3,1,0.026,0.108,0.108,-0.0821,-0.011,线段树updata
May 20 2018 07:34:52,84,3,5,12,2.48,0.931,0.91,0.917,3,1,0.0694,0.0896,0.0832,-0.0139,-0.0021,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
May 20 2018 07:36:08,79,2,4,7,1.65,0.953,0.954,0.943,4,1,0.047,0.0458,0.0568,-0.0098,-0.001,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:37:20,68,3,6,9,1.54,0.93,0.936,0.943,4,1,0.07,0.0636,0.0568,0.0131,0.0017,1
May 20 2018 07:37:39,62,3,4,1,0.25,0.929,0.936,0.943,2,0,0.9285,0.9364,0.9432,-0.0147,-0.0274,2
May 20 2018 07:38:08,19,3,6,9,1.51,0.928,0.938,0.943,4,1,0.0717,0.0622,0.0568,0.0149,0.0019,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:39:11,63,3,5,23,4.64,0.928,0.994,0.943,3,1,0.072,0.0062,0.0568,0.0151,0.0019,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 20 2018 07:40:50,65,5,4,1,0.25,0.823,0.964,0.964,2,0,0.8227,0.9638,0.9638,-0.141,-0.2519,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 20 2018 07:40:59,54,5,12,15,1.26,0.823,0.964,0.964,4,1,0.1773,0.0363,0.0363,0.141,0.0301,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 20 2018 07:42:15,69,3,5,9,1.85,0.928,0.936,0.943,3,1,0.0721,0.0637,0.0568,0.0153,0.002,3
May 20 2018 07:42:29,45,3,6,9,1.53,0.928,0.937,0.943,4,1,0.0724,0.0631,0.0568,0.0155,0.002,4
May 20 2018 07:42:55,21,4,9,18,2.05,0.907,0.885,0.917,4,1,0.0927,0.1147,0.0832,0.0095,0.0017,红黑树旋转
May 21 2018 07:01:51,30,6,11,29,2.6,0.86,0.928,0.928,4,1,0.1397,0.0721,0.0721,0.0676,0.0143,01一维
May 21 2018 07:02:20,65,1,2,3,1.25,0.974,0.903,0.903,4,1,0.0259,0.0975,0.0975,-0.0716,-0.0088,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 21 2018 07:02:35,36,5,12,22,1.8,0.803,0.903,0.903,4,1,0.1971,0.0968,0.0968,0.1003,0.0295,01一维
May 21 2018 07:02:42,24,5,12,22,1.8,0.823,0.903,0.903,4,1,0.1773,0.0968,0.0968,0.0805,0.0221,状态压缩
May 21 2018 07:03:24,62,1,2,6,3.19,0.975,0.902,0.902,4,1,0.0254,0.0977,0.0977,-0.0724,-0.0089,2
May 22 2018 08:29:45,66,6,15,24,1.62,0.74,0.885,0.885,4,1,0.2599,0.1151,0.1151,0.1449,0.0543,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 22 2018 08:30:03,60,6,10,24,2.42,0.74,0.885,0.885,3,1,0.2599,0.1152,0.1152,0.1447,0.0543,黑高
May 22 2018 08:30:18,11,6,16,24,1.51,0.768,0.884,0.884,4,1,0.2316,0.1157,0.1157,0.1158,0.0402,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 23 2018 06:47:21,57,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2122,0.0688,结点属性
May 23 2018 06:47:51,58,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0558,0.0558,0.2123,0.0688,性质
May 23 2018 06:48:18,42,5,10,7,0.74,0.907,0.84,0.84,4,1,0.0929,0.1598,0.1598,-0.0669,-0.0169,完全背包模板
May 23 2018 06:48:26,56,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2123,0.0688,平衡性
May 24 2018 07:25:49,65,3,6,6,0.93,0.877,0.863,0.863,4,1,0.1234,0.1367,0.1367,-0.0133,-0.0035,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 24 2018 07:25:56,59,9,24,25,1.06,0.704,0.937,0.937,4,1,0.2962,0.0629,0.0629,0.2333,0.0838,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 26 2018 07:20:17,50,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树add
May 26 2018 07:20:31,31,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树updata
May 26 2018 07:20:51,44,11,25,34,1.35,0.879,0.923,0.923,4,1,0.1208,0.0765,0.0765,0.0443,0.0087,线段树pushUp
May 26 2018 07:20:59,29,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树类型定义
May 26 2018 07:21:26,49,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树pushDown
May 27 2018 07:33:23,79,7,4,1,0.25,0.872,0.894,0.894,2,0,0.8723,0.8943,0.8943,-0.022,-0.0388,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 27 2018 07:34:38,83,11,4,1,0.25,0.747,0.693,0.843,2,0,0.7468,0.6925,0.8427,-0.0958,-0.1524,删除替换点
May 27 2018 07:35:39,62,6,15,24,1.62,0.74,0.891,0.891,4,1,0.2599,0.1093,0.1093,0.1506,0.0556,2
May 28 2018 10:13:26,79,1,2,1,0.5,0.954,0.89,0.89,2,0,0.9539,0.8895,0.8895,0.0644,0.1187,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 28 2018 10:13:59,83,1,2,7,3.55,0.954,0.89,0.89,3,1,0.0457,0.1104,0.1104,-0.0647,-0.0101,删除替换点
May 28 2018 10:14:35,34,13,2,1,0.5,0.945,0.929,0.929,2,0,0.9454,0.9295,0.9295,0.0159,0.0298,01二维
May 28 2018 10:15:18,35,13,30,35,1.17,0.968,0.93,0.93,4,1,0.0321,0.0705,0.0705,-0.0384,-0.0039,01二维
May 29 2018 09:17:55,18,13,45,20,0.45,0.571,0.644,0.827,4,1,0.4289,0.3563,0.1727,0.2562,0.1541,删除1
May 29 2018 09:18:13,41,14,31,59,1.9,0.822,0.919,0.919,4,1,0.1784,0.0811,0.0811,0.0974,0.0253,完全背包模板
May 29 2018 09:18:25,34,1,2,2,1.23,0.956,0.904,0.904,4,1,0.0442,0.0963,0.0963,-0.0521,-0.0073,01二维
May 29 2018 09:19:29,68,9,14,33,2.36,0.894,0.891,0.891,3,1,0.1063,0.1091,0.1091,-0.0028,-0.0006,1
May 29 2018 09:20:32,19,9,19,33,1.74,0.894,0.89,0.89,4,1,0.1063,0.1098,0.1098,-0.0035,-0.0008,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 29 2018 09:21:13,23,14,24,59,2.46,0.762,0.919,0.919,4,1,0.2382,0.0813,0.0813,0.1568,0.0501,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 29 2018 09:21:54,69,9,2,1,0.5,0.82,0.891,0.891,2,0,0.8202,0.891,0.891,-0.0708,-0.1211,3
May 29 2018 09:22:27,45,9,2,1,0.5,0.893,0.891,0.891,2,0,0.8931,0.8907,0.8907,0.0024,0.0042,4
May 29 2018 09:23:25,79,1,2,1,0.5,0.952,0.903,0.903,2,0,0.9521,0.9033,0.9033,0.0488,0.0906,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 08:59:26,82,3,6,12,2.08,0.877,0.923,0.917,3,1,0.1228,0.0772,0.0832,0.0395,0.0081,找到替换点
May 30 2018 09:00:06,69,1,2,1,0.5,0.95,0.901,0.901,2,0,0.9498,0.9014,0.9014,0.0484,0.0895,3
May 30 2018 09:00:22,79,1,2,3,1.27,0.948,0.902,0.902,4,1,0.052,0.0985,0.0985,-0.0465,-0.007,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 09:00:42,45,1,2,3,1.27,0.953,0.901,0.901,4,1,0.0475,0.0986,0.0986,-0.0511,-0.0075,4
May 30 2018 09:01:24,46,12,29,39,1.34,0.833,0.865,0.865,4,1,0.1668,0.135,0.135,0.0318,0.0096,线段树build
May 30 2018 09:02:19,65,6,11,9,0.8,0.925,0.842,0.842,4,1,0.0751,0.1577,0.1577,-0.0827,-0.0192,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 30 2018 09:02:41,47,12,30,39,1.29,0.837,0.865,0.865,4,1,0.1632,0.135,0.135,0.0282,0.0084,线段树search
May 30 2018 09:03:03,27,15,35,73,2.08,0.849,0.891,0.891,4,1,0.151,0.109,0.109,0.042,0.0109,01二维
May 31 2018 12:19:29,66,9,17,31,1.85,0.96,0.955,0.955,3,1,0.0398,0.0453,0.0453,-0.0055,-0.0005,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 31 2018 12:19:52,34,2,4,5,1.19,0.916,0.901,0.901,4,1,0.0841,0.0989,0.0989,-0.0149,-0.0027,01二维
May 31 2018 12:20:04,60,9,13,31,2.42,0.901,0.955,0.955,4,1,0.0991,0.0453,0.0453,0.0537,0.0078,黑高
May 31 2018 12:20:24,69,1,2,3,1.39,0.95,0.887,0.887,4,1,0.0502,0.1131,0.1131,-0.0629,-0.0103,3
May 31 2018 12:21:19,42,8,13,11,0.82,0.931,0.832,0.832,4,1,0.0685,0.1683,0.1683,-0.0997,-0.0236,完全背包模板
May 31 2018 12:21:23,11,9,18,31,1.75,0.963,0.955,0.955,4,1,0.0369,0.0454,0.0454,-0.0085,-0.0007,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 01 2018 09:08:12,84,12,23,37,1.63,0.769,0.916,0.916,4,1,0.2313,0.0842,0.0842,0.1472,0.0464,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Jun 01 2018 09:08:48,9,15,49,23,0.46,0.509,0.596,0.819,4,1,0.4913,0.404,0.1809,0.3104,0.2087,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:33,79,3,4,6,1.39,0.877,0.865,0.865,3,1,0.1234,0.1351,0.1351,-0.0117,-0.003,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:57,33,18,39,55,1.41,0.951,0.904,0.904,4,1,0.049,0.0958,0.0958,-0.0467,-0.0068,01二维
Jun 02 2018 08:50:10,38,18,32,55,1.72,0.896,0.904,0.904,4,1,0.1043,0.0961,0.0961,0.0082,0.0016,01一维
Jun 02 2018 08:50:34,45,3,6,6,0.93,0.877,0.865,0.865,4,1,0.1234,0.135,0.135,-0.0116,-0.003,4
Jun 02 2018 08:51:00,40,18,43,55,1.28,0.955,0.904,0.904,4,1,0.0447,0.0962,0.0962,-0.0515,-0.0073,完全背包模板
Jun 03 2018 08:28:45,69,3,6,6,0.94,0.877,0.881,0.881,4,1,0.1234,0.119,0.119,0.0044,0.0011,3
Jun 04 2018 07:51:24,117,1,2,1,0.5,0.956,0.969,0.99,2,0,0.9559,0.9685,0.99,-0.0342,-0.0665,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 04 2018 07:52:50,93,2,4,8,2,0.914,0.934,0.943,4,1,0.0861,0.0664,0.0568,0.0292,0.0042,图割点
Jun 04 2018 07:53:15,100,2,4,7,1.86,0.914,0.936,0.943,4,1,0.0858,0.0637,0.0568,0.029,0.0041,修改距离动态规划
Jun 04 2018 07:53:30,54,15,27,67,2.48,0.896,0.911,0.911,3,1,0.104,0.0894,0.0894,0.0146,0.0028,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Jun 04 2018 07:55:00,83,7,18,27,1.49,0.715,0.886,0.886,4,1,0.2847,0.1137,0.1137,0.171,0.0681,删除替换点
Jun 05 2018 17:21:07,129,2,5,9,1.72,0.914,0.929,0.943,4,1,0.0856,0.0706,0.0568,0.0288,0.0041,有向图求欧拉回路：. [.]
Jun 05 2018 17:21:32,34,5,10,8,0.76,0.896,0.836,0.836,4,1,0.1039,0.1636,0.1636,-0.0597,-0.016,01二维
Jun 05 2018 17:22:00,119,2,4,10,2.47,0.915,0.922,0.943,3,1,0.0853,0.0778,0.0568,0.0285,0.004,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 05 2018 17:22:36,91,17,56,25,0.44,0.483,0.553,0.812,4,1,0.5169,0.4471,0.1881,0.3288,0.2318,KMP算法
Jun 05 2018 17:23:29,117,1,2,8,4.03,0.955,0.863,0.863,4,1,0.0446,0.1369,0.1369,-0.0923,-0.0167,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 05 2018 17:23:55,103,3,7,13,1.92,0.879,0.905,0.917,4,1,0.121,0.0946,0.0832,0.0378,0.0077,快速幂
Jun 05 2018 17:24:16,49,10,21,35,1.68,0.962,0.953,0.953,4,1,0.0383,0.0473,0.0473,-0.009,-0.0008,线段树pushDown
Jun 05 2018 17:24:45,80,3,6,18,2.93,0.879,0.889,0.917,3,1,0.1206,0.1106,0.0832,0.0373,0.0076,什么是错排公式？
Jun 05 2018 17:25:26,16,3,7,25,3.59,0.88,0.994,0.917,4,1,0.1202,0.0064,0.0832,0.0369,0.0075,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Jun 06 2018 08:27:47,124,3,7,11,1.56,0.88,0.932,0.917,4,1,0.1197,0.0679,0.0832,0.0365,0.0074,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 06 2018 08:28:25,133,3,2,1,0.5,0.879,0.91,0.917,2,0,0.8791,0.9097,0.9168,-0.0376,-0.0676,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 06 2018 08:28:35,77,3,7,14,2.03,0.88,0.902,0.917,4,1,0.1204,0.098,0.0832,0.0372,0.0076,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G[.]. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 06 2018 08:28:56,125,3,7,11,1.56,0.88,0.932,0.917,4,1,0.12,0.0679,0.0832,0.0368,0.0075,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 06 2018 08:29:08,123,3,2,1,0.5,0.879,0.932,0.917,1,0,0.8787,0.932,0.9168,-0.038,-0.0683,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 06 2018 08:29:26,122,3,2,1,0.5,0.878,0.932,0.917,1,0,0.8775,0.932,0.9168,-0.0393,-0.0704,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 07 2018 08:49:36,128,4,11,19,1.7,0.841,0.877,0.898,4,1,0.1589,0.1228,0.1015,0.0574,0.015,无向图求欧拉回路. [.]
Jun 07 2018 08:50:03,123,1,1,7,6.69,0.955,0.899,0.899,3,1,0.0451,0.1014,0.1014,-0.0563,-0.0082,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 07 2018 08:50:36,85,21,65,29,0.44,0.421,0.483,0.8,4,1,0.5792,0.5171,0.2,0.3792,0.2955,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 07 2018 08:51:05,21,18,42,54,1.29,0.808,0.877,0.877,4,1,0.1918,0.1232,0.1232,0.0685,0.0216,红黑树旋转
Jun 07 2018 08:52:29,122,1,2,7,3.35,0.957,0.898,0.898,4,1,0.0427,0.1015,0.1015,-0.0588,-0.0085,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 08 2018 09:14:52,90,1,2,5,2.69,0.96,0.979,0.99,4,1,0.0402,0.0208,0.01,0.0302,0.0015,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jun 08 2018 09:15:46,65,9,13,12,0.92,0.924,0.839,0.839,3,1,0.076,0.1611,0.1611,-0.0851,-0.0202,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 08 2018 09:17:19,45,6,10,9,0.88,0.932,0.843,0.843,3,1,0.0678,0.1569,0.1569,-0.089,-0.02,4
Jun 08 2018 09:17:43,79,6,8,9,1.1,0.877,0.843,0.843,3,1,0.1225,0.1569,0.1569,-0.0344,-0.0096,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 08 2018 09:19:04,139,1,2,5,2.69,0.96,0.979,0.99,4,1,0.0401,0.0209,0.01,0.0301,0.0015,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jun 08 2018 09:21:12,115,5,14,22,1.56,0.816,0.84,0.885,4,1,0.184,0.1604,0.1154,0.0686,0.0205,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Jun 09 2018 10:17:00,132,3,5,13,2.51,0.885,0.922,0.917,3,1,0.1145,0.0776,0.0832,0.0313,0.0062,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 09 2018 10:17:44,133,3,2,1,0.5,0.884,0.628,0.917,2,0,0.8842,0.6285,0.9168,-0.0325,-0.0586,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 09 2018 10:18:23,69,6,11,9,0.79,0.925,0.84,0.84,4,1,0.0751,0.1602,0.1602,-0.0851,-0.02,3
Jun 09 2018 10:19:08,73,23,67,31,0.47,0.409,0.449,0.8,4,1,0.5913,0.5508,0.2,0.3914,0.3097,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 10 2018 09:58:36,133,1,2,6,3.24,0.959,0.901,0.901,4,1,0.0406,0.0987,0.0987,-0.0582,-0.0081,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 10 2018 09:59:03,50,15,26,51,1.94,0.948,0.953,0.953,4,1,0.0521,0.0468,0.0468,0.0053,0.0005,线段树add
Jun 11 2018 10:21:05,82,12,27,39,1.44,0.822,0.867,0.867,4,1,0.1781,0.1333,0.1333,0.0447,0.0139,找到替换点
Jun 11 2018 10:21:40,62,15,33,58,1.76,0.928,0.927,0.927,4,1,0.0724,0.073,0.073,-0.0005,-0.0001,2
Jun 12 2018 21:46:29,116,9,31,18,0.58,0.708,0.717,0.849,4,1,0.2919,0.2835,0.1511,0.1408,0.0624,2.定理：. 1.[.]充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 13 2018 16:14:14,90,5,13,14,1.1,0.839,0.961,0.961,4,1,0.161,0.0389,0.0389,0.1222,0.0244,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jun 13 2018 16:14:33,93,9,17,29,1.71,0.866,0.934,0.934,3,1,0.1338,0.0659,0.0659,0.068,0.0136,图割点
Jun 13 2018 16:15:17,101,3,5,13,2.63,0.892,0.919,0.917,3,1,0.1084,0.0813,0.0832,0.0251,0.0048,修改距离动态规划
Jun 13 2018 16:15:27,16,8,23,27,1.16,0.925,0.968,0.968,5,1,0.0751,0.0321,0.0321,0.043,0.0046,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Jun 13 2018 16:15:52,117,8,17,30,1.74,0.626,0.885,0.885,4,1,0.3738,0.1147,0.1147,0.2591,0.1266,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 13 2018 16:16:06,34,8,14,11,0.77,0.938,0.839,0.839,4,1,0.0621,0.1609,0.1609,-0.0988,-0.022,01二维
Jun 13 2018 16:16:30,36,23,2,1,0.5,0.8,0.881,0.881,2,0,0.8005,0.8808,0.8808,-0.0803,-0.1351,01一维
Jun 13 2018 16:16:34,24,23,47,100,2.12,0.795,0.881,0.881,4,1,0.2048,0.1192,0.1192,0.0856,0.0277,状态压缩
Jun 13 2018 16:17:27,31,18,37,73,1.97,0.915,0.918,0.918,4,1,0.0851,0.0819,0.0819,0.0032,0.0005,线段树updata
Jun 13 2018 16:18:42,100,3,3,1,0.33,0.89,0.992,0.917,2,0,0.8905,0.9921,0.9168,-0.0263,-0.0475,修改距离动态规划
Jun 13 2018 16:19:06,139,3,7,23,3.27,0.891,0.992,0.917,4,1,0.1091,0.0079,0.0832,0.0259,0.005,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jun 13 2018 16:19:55,63,24,38,105,2.76,0.546,0.897,0.897,4,1,0.4538,0.1029,0.1029,0.3509,0.1954,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
Jun 13 2018 16:22:23,42,13,20,23,1.16,0.901,0.862,0.862,4,1,0.0988,0.1378,0.1378,-0.039,-0.0092,完全背包模板
Jun 16 2018 09:15:20,129,11,3,1,0.33,0.846,0.925,0.925,2,0,0.8461,0.9252,0.9252,-0.0791,-0.1402,有向图求欧拉回路：. [.]
Jun 16 2018 09:16:17,133,6,14,24,1.73,0.736,0.892,0.892,4,1,0.2642,0.1078,0.1078,0.1564,0.0582,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 16 2018 09:16:25,56,24,55,100,1.82,0.898,0.913,0.913,4,1,0.102,0.0871,0.0871,0.0149,0.0028,平衡性
Jun 16 2018 09:16:38,36,3,6,2,0.41,0.876,0.752,0.752,4,1,0.1242,0.2483,0.2483,-0.124,-0.0462,01一维
Jun 16 2018 09:16:46,122,9,17,29,1.7,0.549,0.846,0.846,4,1,0.4512,0.1542,0.1542,0.297,0.1798,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jun 16 2018 09:17:28,57,24,56,100,1.79,0.898,0.913,0.913,4,1,0.1021,0.087,0.087,0.015,0.0028,结点属性
Jun 16 2018 09:17:48,47,17,50,57,1.14,0.964,0.945,0.945,5,1,0.0361,0.0552,0.0552,-0.0192,-0.0017,线段树search
Jun 16 2018 09:17:58,119,11,22,33,1.5,0.715,0.925,0.925,4,1,0.2845,0.0748,0.0748,0.2098,0.0754,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 16 2018 09:18:08,123,9,16,29,1.81,0.507,0.846,0.846,4,1,0.4932,0.1544,0.1544,0.3387,0.2194,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jun 16 2018 09:18:32,100,3,5,2,0.49,0.89,0.752,0.752,4,1,0.1104,0.2482,0.2482,-0.1378,-0.0494,修改距离动态规划
Jun 16 2018 09:18:44,25,32,75,89,1.18,0.97,0.91,0.91,4,1,0.0298,0.0903,0.0903,-0.0605,-0.0073,状态压缩
Jun 16 2018 09:19:31,95,14,2,1,0.5,0.564,0.611,0.823,2,0,0.5643,0.6112,0.8231,-0.2588,-0.359,图割点
Jun 16 2018 09:19:43,46,17,35,57,1.62,0.963,0.945,0.945,4,1,0.0367,0.0552,0.0552,-0.0186,-0.0017,线段树build
Jun 16 2018 09:20:04,58,24,43,100,2.33,0.897,0.913,0.913,3,1,0.1025,0.0872,0.0872,0.0153,0.0029,性质
Jun 16 2018 09:20:20,20,32,76,89,1.17,0.969,0.91,0.91,4,1,0.0306,0.0903,0.0903,-0.0598,-0.0072,状态压缩
Jun 17 2018 17:40:01,124,11,26,40,1.52,0.893,0.896,0.896,4,1,0.1068,0.1041,0.1041,0.0026,0.0006,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 17 2018 17:40:33,79,9,13,23,1.76,0.882,0.935,0.935,4,1,0.1178,0.0647,0.0647,0.0531,0.0097,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 18 2018 16:57:23,129,2,4,3,0.67,0.919,0.783,0.783,4,1,0.0815,0.2169,0.2169,-0.1354,-0.0404,有向图求欧拉回路：. [.]
Jun 18 2018 16:57:51,125,12,2,1,0.5,0.882,0.888,0.888,2,0,0.8818,0.8875,0.8875,-0.0057,-0.0101,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 18 2018 16:58:58,103,13,36,30,0.83,0.869,0.954,0.954,4,1,0.131,0.0459,0.0459,0.0851,0.0151,快速幂
Jun 18 2018 16:59:14,128,11,26,30,1.16,0.933,0.96,0.96,4,1,0.0667,0.0402,0.0402,0.0265,0.0028,无向图求欧拉回路. [.]
Jun 18 2018 16:59:24,108,15,51,15,0.29,0.557,0.584,0.584,4,1,0.4428,0.416,0.416,0.0269,0.0231,AVL
Jun 18 2018 16:59:45,95,2,4,7,1.64,0.922,0.783,0.783,4,1,0.0783,0.2168,0.2168,-0.1386,-0.0409,图割点
Jun 18 2018 17:01:03,19,20,3,1,0.33,0.897,0.95,0.95,2,0,0.8973,0.9498,0.9498,-0.0525,-0.0969,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 18 2018 17:01:57,45,10,13,18,1.38,0.893,0.903,0.924,3,1,0.1065,0.0967,0.0763,0.0302,0.0055,4
Jun 18 2018 17:02:06,18,20,54,47,0.88,0.974,0.937,0.949,4,1,0.026,0.063,0.0512,-0.0252,-0.0019,删除1
Jun 18 2018 17:02:13,59,25,59,93,1.58,0.907,0.932,0.955,4,1,0.0925,0.0677,0.0449,0.0476,0.0065,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
Jun 18 2018 17:02:19,10,34,80,69,0.86,0.969,0.948,0.948,4,1,0.0306,0.0521,0.0521,-0.0214,-0.0018,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 18 2018 17:02:36,14,34,80,69,0.86,0.969,0.948,0.948,4,1,0.0306,0.0521,0.0521,-0.0215,-0.0018,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
Jun 18 2018 17:03:32,69,9,2,1,0.5,0.926,0.919,0.947,2,0,0.9263,0.9191,0.9467,-0.0204,-0.0383,3
Jun 18 2018 17:05:18,66,18,33,62,1.89,0.887,0.935,0.935,4,1,0.1132,0.0646,0.0646,0.0487,0.0087,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 19 2018 09:41:45,125,1,2,2,0.8,0.96,0.929,0.944,4,1,0.0398,0.0708,0.0562,-0.0164,-0.0016,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 19 2018 09:42:14,30,29,49,134,2.73,0.701,0.882,0.923,4,1,0.2991,0.118,0.0769,0.2222,0.0835,01一维
Jun 19 2018 09:42:35,89,33,93,25,0.27,0.3,0.463,0.463,4,1,0.6997,0.5368,0.5368,0.1629,0.2014,typedef struct RBtree. {. [红黑树的结构定义]. } rbtree;
Jun 19 2018 09:43:28,69,1,2,2,0.79,0.957,0.929,0.953,4,1,0.0431,0.0705,0.0467,-0.0036,-0.0003,3
Jun 19 2018 09:45:06,12,35,62,98,1.58,0.553,0.948,0.965,4,1,0.4466,0.052,0.0349,0.4117,0.1983,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 19 2018 09:46:05,19,1,2,2,0.8,0.962,0.929,0.96,4,1,0.0376,0.0709,0.0405,-0.0029,-0.0002,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 20 2018 06:37:43,77,14,39,42,1.09,0.862,0.956,0.97,4,1,0.1384,0.0437,0.0296,0.1088,0.0183,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G[.]. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 21 2018 18:03:31,125,2,4,4,1.07,0.925,0.933,0.947,4,1,0.0751,0.0668,0.053,0.022,0.0028,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 21 2018 18:03:48,100,5,8,10,1.31,0.929,0.871,0.899,4,1,0.0706,0.1287,0.1012,-0.0307,-0.0053,修改距离动态规划
Jun 21 2018 18:04:12,19,2,3,5,1.72,0.916,0.901,0.935,3,1,0.0841,0.0992,0.065,0.0191,0.0028,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 21 2018 18:04:56,65,13,20,24,1.2,0.894,0.923,0.923,4,1,0.106,0.077,0.077,0.029,0.0053,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jun 21 2018 18:05:09,36,5,9,12,1.35,0.937,0.872,0.929,4,1,0.063,0.1283,0.0714,-0.0084,-0.0011,01一维
Jun 21 2018 18:05:31,69,2,4,7,1.79,0.916,0.941,0.97,4,1,0.0841,0.0593,0.0303,0.0537,0.0061,3
Jun 21 2018 18:08:29,146,1,16,33,2.06,0.965,0.996,0.995,4,1,0.0352,0.0042,0.0045,0.0307,0.0012,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Jun 23 2018 15:55:29,146,2,4,32,8.08,0.938,0.993,0.994,4,1,0.0619,0.0069,0.006,0.0558,0.0038,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Jun 23 2018 15:55:39,118,3,8,39,4.94,0.898,0.99,0.992,4,1,0.1017,0.0103,0.0078,0.0938,0.0103,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while(mid*mid - xx > 0.001 || mid*mid - xx < -0.001) .
Jun 23 2018 15:56:55,121,20,66,52,0.78,0.503,0.937,0.968,4,1,0.4967,0.0626,0.0319,0.4648,0.2457,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Jun 23 2018 15:57:28,80,18,38,61,1.61,0.716,0.951,0.977,4,1,0.284,0.0494,0.0233,0.2607,0.0801,什么是错排公式？
Jun 23 2018 15:57:57,129,5,10,11,1.12,0.907,0.89,0.952,4,1,0.0929,0.1095,0.048,0.0449,0.0063,有向图求欧拉回路：. [.]
Jun 23 2018 15:58:46,83,19,46,66,1.44,0.927,0.934,0.962,4,1,0.0731,0.0665,0.0381,0.035,0.0039,删除替换点
Jun 23 2018 16:01:27,132,14,3,1,0.33,0.743,0.887,0.887,2,0,0.7431,0.8872,0.8872,-0.1441,-0.2349,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 24 2018 11:09:02,132,1,2,2,0.95,0.964,0.919,0.964,4,1,0.0361,0.0805,0.0361,0,0,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 24 2018 11:10:31,9,23,62,49,0.78,0.974,0.949,0.949,4,1,0.026,0.0507,0.0507,-0.0247,-0.0019,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 24 2018 11:10:47,84,23,47,63,1.34,0.942,0.954,0.966,4,1,0.0579,0.046,0.0337,0.0242,0.0022,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Jun 26 2018 13:35:32,132,2,3,5,1.83,0.916,0.89,0.956,3,1,0.0841,0.1101,0.0437,0.0403,0.0052,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 26 2018 13:36:12,19,5,3,1,0.33,0.864,0.902,0.957,2,0,0.8639,0.9016,0.9565,-0.0927,-0.1687,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 26 2018 13:37:30,94,24,3,1,0.33,0.428,0.926,0.966,2,0,0.4284,0.9257,0.9664,-0.538,-0.7505,图割点
Jun 26 2018 13:37:48,140,18,3,1,0.33,0.494,0.689,0.689,1,0,0.494,0.6885,0.6885,-0.1946,-0.2301,int gcd(int a_int b). {. [.]. }
Jun 26 2018 13:38:10,101,13,25,44,1.76,0.748,0.902,0.902,4,1,0.2517,0.0982,0.0982,0.1536,0.0537,修改距离动态规划
Jun 26 2018 13:38:19,125,5,9,7,0.83,0.896,0.874,0.837,4,1,0.1039,0.1261,0.1625,-0.0586,-0.0156,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jun 26 2018 13:38:38,150,2,4,11,2.66,0.925,0.808,0.894,4,1,0.0753,0.1918,0.1056,-0.0302,-0.0055,public class Solution { .     /* .     http://www.programcreek.com/2014/02/leetcode-majority-element-java/ .     */ .     public int majorityElement(int[] nums) { .
Jun 26 2018 13:38:51,49,21,38,56,1.48,0.882,0.949,0.949,4,1,0.1176,0.0506,0.0506,0.067,0.0113,线段树pushDown
Jun 26 2018 13:39:21,34,13,25,28,1.13,0.896,0.92,0.964,5,1,0.1043,0.0802,0.036,0.0684,0.0096,01二维
Jun 26 2018 13:39:43,95,8,18,27,1.52,0.819,0.914,0.914,4,1,0.1805,0.0855,0.0855,0.095,0.0253,图割点
Jun 27 2018 15:32:58,90,14,35,46,1.31,0.928,0.956,0.974,4,1,0.0721,0.0442,0.0261,0.046,0.0045,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jun 27 2018 15:33:18,140,1,2,7,3.75,0.959,0.892,0.94,4,1,0.0406,0.1076,0.0602,-0.0196,-0.002,int gcd(int a_int b). {. [.]. }
Jun 27 2018 15:33:29,132,1,1,3,3.03,0.943,0.968,0.764,4,1,0.0569,0.0316,0.2357,-0.1788,-0.0523,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 27 2018 15:33:43,19,1,2,3,1.46,0.957,0.892,0.961,4,1,0.0433,0.1077,0.0392,0.004,0.0003,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 27 2018 15:35:05,94,1,2,6,3.14,0.959,0.911,0.956,4,1,0.0406,0.0885,0.044,-0.0034,-0.0003,图割点
Jun 27 2018 15:35:28,35,30,57,105,1.85,0.885,0.955,0.977,4,1,0.1152,0.0445,0.0234,0.0918,0.0127,01二维
Jun 28 2018 08:45:47,69,7,14,11,0.8,0.852,0.851,0.879,4,1,0.1479,0.1495,0.1212,0.0266,0.0072,3
Jun 29 2018 09:55:19,98,26,81,20,0.25,0.376,0.393,0.393,3,1,0.6243,0.6071,0.6071,0.0172,0.0212,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Jun 29 2018 09:55:36,29,34,65,94,1.45,0.821,0.941,0.958,4,1,0.1794,0.059,0.0418,0.1375,0.0304,线段树类型定义
Jun 29 2018 09:56:04,44,34,64,94,1.47,0.819,0.941,0.958,4,1,0.1814,0.0591,0.0419,0.1396,0.0312,线段树pushUp
Jun 30 2018 09:42:10,132,3,5,5,1,0.81,0.912,0.863,4,1,0.19,0.0882,0.137,0.053,0.0173,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 30 2018 09:42:26,147,10,39,18,0.45,0.688,0.606,0.835,4,1,0.3116,0.3936,0.165,0.1465,0.0698,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while([.]).     {.         if(mid*mid > xx){ .
Jun 30 2018 09:42:31,115,22,63,47,0.74,0.881,0.949,0.949,4,1,0.1191,0.0505,0.0505,0.0685,0.0116,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Jun 30 2018 09:43:07,106,27,81,21,0.26,0.377,0.419,0.419,3,1,0.6229,0.5805,0.5805,0.0423,0.051,AVL
Jun 30 2018 09:43:26,19,3,5,5,1.07,0.86,0.905,0.882,4,1,0.1397,0.0947,0.1183,0.0214,0.0055,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 30 2018 09:43:42,91,25,64,60,0.94,0.974,0.957,0.957,4,1,0.0255,0.0429,0.0429,-0.0174,-0.0012,KMP算法
Jun 30 2018 09:44:12,133,14,3,1,0.33,0.934,0.944,0.968,2,0,0.9342,0.944,0.9675,-0.0333,-0.0633,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jun 30 2018 09:44:48,116,18,50,55,1.09,0.965,0.966,0.966,4,1,0.0347,0.0337,0.0337,0.0009,0.0001,2.定理：. 1.[.]充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jun 30 2018 09:45:07,93,17,27,89,3.3,0.885,0.966,0.985,4,1,0.1152,0.0337,0.0146,0.1006,0.0131,图割点
Jul 01 2018 09:06:50,133,1,2,1,0.5,0.959,0.902,0.967,2,0,0.9592,0.9025,0.9668,-0.0076,-0.0146,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 01 2018 09:06:58,100,10,15,17,1.15,0.866,0.879,0.879,4,1,0.134,0.1212,0.1212,0.0128,0.0033,修改距离动态规划
Jul 01 2018 09:07:54,60,31,43,99,2.29,0.748,0.925,0.941,4,1,0.2521,0.0749,0.0585,0.1935,0.0601,黑高
Jul 01 2018 09:08:37,68,33,47,108,2.31,0.738,0.92,0.936,4,1,0.2625,0.0803,0.0641,0.1984,0.0648,1
Jul 01 2018 09:08:52,11,31,57,94,1.65,0.8,0.931,0.969,4,1,0.2,0.0692,0.0315,0.1686,0.039,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jul 02 2018 11:03:20,143,24,3,1,0.33,0.409,0.405,0.405,1,0,0.409,0.4055,0.4055,0.0035,0.0028,int gcd2 (int a_ int b) . { . [.]. }
Jul 02 2018 11:03:44,133,1,2,3,1.46,0.956,0.892,0.966,4,1,0.0437,0.1077,0.0337,0.01,0.0008,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 02 2018 11:04:59,96,30,83,23,0.27,0.343,0.288,0.288,3,1,0.6572,0.7124,0.7124,-0.0552,-0.0755,图割点
Jul 05 2018 22:14:50,132,5,8,11,1.33,0.929,0.898,0.959,4,1,0.0706,0.1022,0.0408,0.0298,0.0033,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 05 2018 22:15:02,129,12,23,27,1.17,0.89,0.907,0.966,4,1,0.1101,0.0926,0.0342,0.0759,0.0109,有向图求欧拉回路：. [.]
Jul 05 2018 22:15:26,107,32,88,25,0.28,0.33,0.445,0.445,4,1,0.67,0.5552,0.5552,0.1148,0.1407,AVL
Jul 05 2018 22:16:27,102,32,88,24,0.27,0.34,0.293,0.293,4,1,0.6596,0.7074,0.7074,-0.0478,-0.0653,AVL
Jul 05 2018 22:16:38,94,8,20,31,1.54,0.697,0.89,0.89,4,1,0.303,0.1096,0.1096,0.1934,0.0798,图割点
Jul 05 2018 22:16:43,140,8,20,31,1.54,0.697,0.89,0.89,4,1,0.303,0.1098,0.1098,0.1932,0.0798,int gcd(int a_int b). {. [.]. }
Jul 05 2018 22:16:54,143,3,5,10,1.98,0.901,0.694,0.884,4,1,0.0994,0.3061,0.1159,-0.0165,-0.0036,int gcd2 (int a_ int b) . { . [.]. }
Jul 05 2018 22:17:06,36,14,26,25,0.97,0.837,0.885,0.958,4,1,0.163,0.1148,0.0416,0.1214,0.0249,01一维
Jul 05 2018 22:17:12,27,36,85,97,1.14,0.918,0.945,0.963,4,1,0.0824,0.0546,0.0365,0.0459,0.0055,01二维
Jul 05 2018 22:18:04,133,3,6,9,1.46,0.89,0.825,0.951,4,1,0.1105,0.1753,0.0492,0.0613,0.0098,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 05 2018 22:18:11,111,32,94,39,0.41,0.365,0.07,0.687,4,1,0.6352,0.9301,0.3134,0.3219,0.3053,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的[.]我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Jul 05 2018 22:19:37,19,5,8,9,1.11,0.937,0.903,0.863,4,1,0.063,0.0966,0.1374,-0.0745,-0.0149,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 05 2018 22:19:43,125,9,16,15,0.91,0.932,0.9,0.874,4,1,0.0678,0.1001,0.1255,-0.0577,-0.0112,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jul 06 2018 09:09:40,139,23,3,1,0.33,0.731,0.957,0.982,1,0,0.7312,0.9575,0.9825,-0.2513,-0.4307,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jul 06 2018 09:10:37,45,18,27,31,1.15,0.862,0.919,0.919,4,1,0.1384,0.0814,0.0814,0.057,0.0125,4
Jul 06 2018 09:11:54,87,33,91,24,0.27,0.363,0.255,0.255,3,1,0.6369,0.7447,0.7447,-0.1078,-0.1489,AVL
Jul 06 2018 09:13:27,85,29,71,76,1.07,0.976,0.96,0.96,3,1,0.0241,0.0399,0.0399,-0.0158,-0.001,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 06 2018 09:13:59,42,23,39,54,1.39,0.894,0.925,0.925,4,1,0.1061,0.0751,0.0751,0.031,0.0056,完全背包模板
Jul 07 2018 21:35:06,139,1,2,5,2.28,0.967,0.852,0.958,4,1,0.0326,0.1478,0.042,-0.0094,-0.0007,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jul 07 2018 21:36:39,138,30,3,1,0.33,0.39,0.224,0.738,2,0,0.39,0.2243,0.7381,-0.3481,-0.3927,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 状态转移： . [.]
Jul 07 2018 21:37:06,150,11,31,76,2.45,0.851,0.966,0.989,4,1,0.1487,0.0338,0.0108,0.1379,0.022,public class Solution { .     /* .     http://www.programcreek.com/2014/02/leetcode-majority-element-java/ .     */ .     public int majorityElement(int[] nums) { .
Jul 08 2018 11:40:44,138,1,2,3,1.52,0.967,0.94,0.978,4,1,0.0332,0.0599,0.0217,0.0115,0.0006,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 状态转移： . [.]
Jul 08 2018 11:41:00,108,20,54,71,1.32,0.978,0.971,0.971,4,1,0.0221,0.0291,0.0291,-0.0071,-0.0004,AVL
Jul 08 2018 11:41:17,82,27,58,83,1.43,0.929,0.934,0.97,4,1,0.0709,0.0662,0.0302,0.0407,0.0041,找到替换点
Jul 08 2018 11:41:30,15,54,134,136,1.02,0.885,0.944,0.951,4,1,0.1145,0.0559,0.0486,0.0659,0.0107,*************************************************分割线. 单点更新. 当我们修改A[]数组中的某一个值时  应当如何更新C[]数组呢？. 回想一下 区间查询的过程，再看一下上文中列出的图. 结合代码分析. void add(int x_int y) . { . for(int .
Jul 09 2018 10:43:09,113,36,106,26,0.24,0.333,0.237,0.237,4,1,0.6665,0.7631,0.7631,-0.0966,-0.138,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的[.]我们称之为欧拉回路. 5.欧拉图： .
Jul 09 2018 10:43:41,69,11,20,18,0.89,0.951,0.916,0.884,4,1,0.0489,0.0842,0.1155,-0.0666,-0.0109,3
Jul 10 2018 21:45:52,79,23,3,1,0.33,0.846,0.903,0.937,2,0,0.8463,0.9035,0.9367,-0.0904,-0.1612,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 10 2018 21:46:00,16,27,75,99,1.32,0.917,0.968,0.974,4,1,0.0826,0.0323,0.0262,0.0564,0.0061,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Jul 10 2018 21:46:16,73,31,80,80,1,0.976,0.959,0.959,4,1,0.0236,0.0411,0.0411,-0.0175,-0.0011,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 13 2018 11:15:10,139,6,15,11,0.75,0.791,0.879,0.908,4,1,0.2087,0.121,0.0917,0.1171,0.0352,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jul 13 2018 11:19:20,66,25,41,60,1.45,0.94,0.955,0.955,4,1,0.0603,0.0455,0.0455,0.0149,0.0016,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jul 13 2018 11:19:40,117,30,72,98,1.36,0.849,0.931,0.978,4,1,0.1512,0.0694,0.0217,0.1295,0.0224,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jul 13 2018 11:20:02,138,5,12,20,1.68,0.803,0.864,0.864,4,1,0.1971,0.1364,0.1364,0.0607,0.0202,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 状态转移： . [.]
Jul 13 2018 11:20:18,79,3,5,6,1.24,0.886,0.763,0.939,4,1,0.1137,0.2369,0.061,0.0528,0.0092,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 13 2018 11:20:28,114,40,116,29,0.25,0.315,0.147,0.147,4,1,0.6851,0.853,0.853,-0.1679,-0.2583,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. [ .
Jul 13 2018 11:20:44,112,40,116,28,0.25,0.323,0.164,0.164,4,1,0.6768,0.8357,0.8357,-0.1589,-0.2403,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. [.]. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. 具有欧拉回路的图称之为欧拉图，规定平凡图（只有一个顶点的空图）属于欧拉图. 6.半欧拉图： .
Jul 14 2018 09:29:49,133,9,3,1,0.33,0.9,0.881,0.873,2,0,0.9,0.8811,0.8732,0.0268,0.0475,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 14 2018 09:30:04,19,9,15,10,0.69,0.924,0.885,0.776,4,1,0.0762,0.115,0.2237,-0.1475,-0.0442,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 14 2018 09:38:28,62,33,63,98,1.55,0.895,0.933,0.97,4,1,0.1054,0.0666,0.0304,0.075,0.0102,2
Jul 15 2018 17:41:33,143,10,3,4,1.26,0.856,0.917,0.917,2,0,0.8558,0.9171,0.9171,-0.0613,-0.1087,int gcd2 (int a_ int b) . { . [.]. }
Jul 15 2018 17:41:48,123,29,3,1,0.41,0.878,0.937,0.971,2,0,0.8775,0.9365,0.9709,-0.0934,-0.1726,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jul 15 2018 17:41:54,122,29,63,86,1.37,0.872,0.936,0.971,4,1,0.1283,0.0635,0.0291,0.0992,0.0156,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Jul 15 2018 17:42:23,65,24,38,130,3.42,0.878,0.96,0.987,4,1,0.1219,0.0398,0.0134,0.1085,0.0147,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Jul 15 2018 17:42:41,133,1,2,4,1.97,0.962,0.868,0.966,4,1,0.0378,0.1319,0.0336,0.0042,0.0003,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 24 2018 14:50:41,90,27,49,139,2.85,0.938,0.956,0.986,4,1,0.0624,0.044,0.0138,0.0486,0.0037,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Jul 24 2018 14:53:16,132,19,28,17,0.59,0.737,0.78,0.822,4,1,0.2626,0.2205,0.1778,0.0848,0.0373,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 24 2018 14:54:40,79,11,3,1,0.33,0.833,0.841,0.823,2,0,0.8328,0.8412,0.8227,0.0101,0.0167,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 24 2018 14:55:15,139,11,23,14,0.63,0.955,0.904,0.819,4,1,0.0449,0.096,0.1814,-0.1364,-0.0309,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Jul 24 2018 14:56:13,63,41,74,123,1.66,0.923,0.948,0.973,4,1,0.0765,0.052,0.0269,0.0496,0.0051,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
Jul 24 2018 14:56:34,119,38,3,1,0.44,0.831,0.95,0.985,2,0,0.8313,0.9505,0.9849,-0.1536,-0.2791,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jul 24 2018 14:56:59,128,36,52,126,2.43,0.802,0.958,0.976,4,1,0.1981,0.042,0.0237,0.1745,0.0387,无向图求欧拉回路. [.]
Jul 24 2018 14:58:01,21,47,73,130,1.79,0.865,0.951,0.969,4,1,0.1354,0.0492,0.0314,0.104,0.0173,红黑树旋转
Jul 24 2018 14:58:19,123,9,3,1,0.33,0.743,0.392,0.867,2,0,0.7426,0.3921,0.8671,-0.1245,-0.2004,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jul 24 2018 14:58:48,84,30,44,100,2.28,0.923,0.969,0.969,4,1,0.0768,0.0315,0.0315,0.0453,0.0049,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Jul 24 2018 14:59:07,121,31,3,1,0.33,0.97,0.961,0.961,2,0,0.9699,0.961,0.961,0.0089,0.0172,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Jul 24 2018 14:59:22,80,31,50,127,2.55,0.912,0.957,0.981,4,1,0.0875,0.0426,0.0189,0.0687,0.0073,什么是错排公式？
Jul 24 2018 14:59:44,147,24,51,69,1.35,0.96,0.963,0.963,4,1,0.0397,0.037,0.037,0.0027,0.0002,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while([.]).     {.         if(mid*mid > xx){ .
Jul 24 2018 15:02:32,100,23,34,57,1.68,0.859,0.9,0.935,4,1,0.1406,0.1001,0.0655,0.0751,0.0155,修改距离动态规划
Jul 24 2018 15:02:56,133,9,18,18,0.98,0.673,0.789,0.951,4,1,0.3268,0.2115,0.0488,0.278,0.1044,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Jul 24 2018 15:03:07,34,28,47,46,0.99,0.91,0.88,0.88,4,1,0.0897,0.1197,0.1197,-0.0299,-0.0063,01二维
Jul 24 2018 15:03:24,143,9,3,1,0.33,0.741,0.392,0.874,2,0,0.7413,0.3919,0.8744,-0.1331,-0.2151,int gcd2 (int a_ int b) . { . [.]. }
Jul 24 2018 15:04:58,125,19,28,33,1.18,0.867,0.9,0.9,4,1,0.1326,0.1,0.1,0.0326,0.0076,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jul 24 2018 15:05:21,95,28,44,95,2.17,0.824,0.924,0.966,4,1,0.1764,0.0762,0.0343,0.142,0.0299,图割点
Jul 24 2018 15:07:31,103,36,3,1,0.33,0.87,0.948,0.978,2,0,0.8702,0.9476,0.9775,-0.1074,-0.1984,快速幂
Jul 26 2018 16:37:30,146,33,3,1,0.33,0.262,0.908,0.959,2,0,0.2616,0.9076,0.959,-0.6974,-0.8513,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Jul 26 2018 16:37:38,148,33,48,24,0.51,0.4,0.242,0.242,4,1,0.5996,0.7577,0.7577,-0.1581,-0.2146,【?】我们假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。
Jul 26 2018 16:39:15,143,2,3,1,0.33,0.926,0.865,0.97,2,0,0.9256,0.8653,0.9705,-0.0449,-0.0851,int gcd2 (int a_ int b) . { . [.]. }
Jul 26 2018 16:39:25,123,2,3,5,1.83,0.925,0.804,0.961,3,1,0.0748,0.196,0.0393,0.0356,0.0041,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Jul 26 2018 16:39:30,121,2,4,5,1.37,0.937,0.804,0.962,4,1,0.0627,0.1959,0.0376,0.0251,0.0025,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Jul 26 2018 16:40:33,79,2,3,4,1.48,0.917,0.804,0.906,3,1,0.0832,0.1963,0.0944,-0.0112,-0.002,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 26 2018 16:40:54,119,2,3,1,0.33,0.93,0.885,0.932,2,0,0.93,0.8848,0.9319,-0.0019,-0.0036,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jul 26 2018 16:41:21,25,40,54,176,3.26,0.913,0.976,0.976,4,1,0.0869,0.024,0.024,0.0629,0.007,状态压缩
Jul 26 2018 16:42:24,103,2,3,4,1.42,0.931,0.855,0.871,4,1,0.0692,0.1454,0.1292,-0.0601,-0.0119,快速幂
Jul 27 2018 15:39:06,146,1,2,2,1.06,0.965,0.904,0.822,4,1,0.0352,0.0961,0.1782,-0.1431,-0.0305,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Jul 27 2018 15:39:16,119,1,2,2,1.06,0.962,0.904,0.838,4,1,0.038,0.0959,0.1622,-0.1242,-0.0249,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Jul 27 2018 15:39:31,38,55,69,153,2.22,0.775,0.951,0.969,4,1,0.2248,0.049,0.0312,0.1936,0.0495,01一维
Jul 27 2018 15:39:45,23,59,75,212,2.83,0.712,0.89,0.946,4,1,0.2876,0.1098,0.0539,0.2337,0.0798,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
Jul 27 2018 15:40:46,124,40,55,144,2.62,0.767,0.903,0.961,4,1,0.233,0.0968,0.0388,0.1941,0.0528,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Jul 27 2018 15:41:01,143,1,2,2,1.06,0.957,0.904,0.848,4,1,0.0433,0.0962,0.1519,-0.1086,-0.0212,int gcd2 (int a_ int b) . { . [.]. }
Jul 27 2018 15:41:48,69,18,23,37,1.6,0.888,0.918,0.946,3,1,0.1116,0.0821,0.0541,0.0575,0.0095,3
Jul 27 2018 15:42:47,41,59,79,190,2.41,0.73,0.91,0.96,4,1,0.2699,0.0899,0.04,0.23,0.0713,完全背包模板
Jul 27 2018 15:43:07,19,13,3,3,0.87,0.902,0.887,0.837,2,0,0.9022,0.887,0.8374,0.0648,0.1127,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jul 27 2018 15:43:14,33,55,71,153,2.16,0.78,0.951,0.969,4,1,0.2196,0.049,0.0312,0.1884,0.0472,01二维
Jul 27 2018 15:43:20,40,55,73,153,2.1,0.788,0.951,0.969,4,1,0.2121,0.049,0.0312,0.1809,0.044,完全背包模板
Aug 03 2018 13:58:10,146,7,15,6,0.42,0.828,0.71,0.834,4,1,0.1723,0.2902,0.1659,0.0064,0.0022,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Aug 03 2018 13:58:47,138,21,38,75,1.97,0.857,0.932,0.969,4,1,0.1428,0.0676,0.0308,0.112,0.0195,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 状态转移： . [.]
Aug 03 2018 13:59:04,129,29,3,9,3,0.835,0.899,0.899,2,0,0.8345,0.8992,0.8992,-0.0647,-0.1121,有向图求欧拉回路：. [.]
Aug 03 2018 13:59:09,98,35,62,90,1.45,0.965,0.959,0.959,4,1,0.0346,0.0407,0.0407,-0.0061,-0.0005,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Aug 03 2018 13:59:24,143,7,14,10,0.69,0.735,0.713,0.912,4,1,0.2646,0.2874,0.0884,0.1762,0.0622,int gcd2 (int a_ int b) . { . [.]. }
Aug 03 2018 13:59:30,118,41,57,103,1.81,0.367,0.906,0.906,4,1,0.6331,0.0941,0.0941,0.539,0.3919,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while(mid*mid - xx > 0.001 || mid*mid - xx < -0.001) .
Aug 03 2018 13:59:49,19,7,9,6,0.68,0.756,0.482,0.826,4,1,0.2442,0.5181,0.1738,0.0704,0.0294,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 03 2018 13:59:58,119,7,14,5,0.33,0.761,0.656,0.726,4,1,0.239,0.3435,0.2737,-0.0347,-0.0178,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Aug 03 2018 14:00:16,49,38,55,92,1.67,0.88,0.935,0.935,4,1,0.1197,0.0653,0.0653,0.0544,0.0101,线段树pushDown
Aug 03 2018 14:00:24,77,44,69,141,2.05,0.834,0.94,0.977,4,1,0.1656,0.0602,0.0234,0.1422,0.0269,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G[.]. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Aug 03 2018 14:00:30,89,45,80,101,1.26,0.956,0.954,0.954,4,1,0.044,0.0464,0.0464,-0.0024,-0.0002,typedef struct RBtree. {. [红黑树的结构定义]. } rbtree;
Aug 03 2018 14:00:42,36,29,47,30,0.65,0.885,0.829,0.836,4,1,0.1155,0.1705,0.1636,-0.0481,-0.0134,01一维
Aug 03 2018 14:01:07,106,34,65,91,1.4,0.973,0.961,0.961,4,1,0.0272,0.0393,0.0393,-0.0121,-0.0008,AVL
Aug 03 2018 14:01:35,103,8,16,15,0.91,0.869,0.811,0.916,4,1,0.1311,0.1889,0.0838,0.0472,0.0102,快速幂
Aug 03 2018 14:01:40,121,8,17,15,0.88,0.89,0.81,0.92,4,1,0.1105,0.19,0.0805,0.03,0.0057,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Aug 03 2018 14:02:07,79,8,14,13,0.9,0.796,0.756,0.926,4,1,0.2045,0.2445,0.0737,0.1308,0.0364,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 03 2018 14:03:04,50,54,68,192,2.82,0.736,0.953,0.978,4,1,0.2637,0.0468,0.0222,0.2414,0.069,线段树add
Aug 03 2018 14:03:16,123,8,15,11,0.75,0.837,0.819,0.868,4,1,0.1633,0.1815,0.1323,0.0309,0.0091,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Aug 05 2018 08:58:52,140,31,44,94,2.14,0.81,0.929,0.973,3,1,0.1897,0.0707,0.0269,0.1628,0.0353,int gcd(int a_int b). {. [.]. }
Aug 05 2018 08:59:08,18,48,74,243,3.29,0.861,0.963,0.985,4,1,0.139,0.0371,0.0148,0.1243,0.0191,删除1
Aug 05 2018 08:59:37,94,31,52,94,1.81,0.811,0.929,0.973,4,1,0.1887,0.0707,0.0269,0.1618,0.0349,图割点
Aug 06 2018 11:52:20,45,31,47,67,1.42,0.892,0.917,0.953,4,1,0.1081,0.0828,0.0469,0.0613,0.0095,4
Aug 07 2018 16:58:35,30,49,71,257,3.62,0.891,0.964,0.986,4,1,0.1092,0.0361,0.0145,0.0948,0.0117,01一维
Aug 09 2018 16:37:33,7,86,112,243,2.17,0.69,0.916,0.937,4,1,0.3096,0.0843,0.0634,0.2462,0.0918,树状数组彻底入门int lowbit(int t) . { . [.] . }. void add(int x_int y) . { . for(int i=x;i<=n;i+=lowbit(i)) . tree[i]+=y; . }. int getsum(int x) . { . int ans=0; . for(int i=x;i>0;i .
Aug 09 2018 16:38:16,96,38,73,90,1.23,0.971,0.956,0.956,4,1,0.0295,0.0445,0.0445,-0.015,-0.0011,图割点
Aug 09 2018 16:39:04,101,44,3,9,3,0.811,0.9,0.966,2,0,0.8106,0.8998,0.966,-0.1555,-0.2762,修改距离动态规划
Aug 09 2018 16:39:08,29,41,65,129,1.98,0.942,0.962,0.97,4,1,0.058,0.0377,0.0305,0.0276,0.0024,线段树类型定义
Aug 09 2018 16:39:21,139,16,26,17,0.65,0.949,0.872,0.784,4,1,0.0514,0.1277,0.2158,-0.1645,-0.0439,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Aug 11 2018 21:08:38,133,18,30,21,0.71,0.943,0.802,0.87,3,1,0.0573,0.1978,0.1303,-0.073,-0.0137,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Aug 11 2018 21:09:24,54,68,3,1,0.33,0.679,0.927,0.949,2,0,0.6792,0.9267,0.9489,-0.2697,-0.4391,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Aug 11 2018 21:09:41,68,41,62,175,2.82,0.92,0.961,0.981,4,1,0.0799,0.0387,0.0189,0.061,0.006,1
Aug 17 2018 22:04:49,146,14,3,1,0.43,0.96,0.809,0.861,2,0,0.9595,0.8091,0.8606,0.0989,0.18,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Aug 17 2018 22:05:45,129,14,19,7,0.36,0.592,0.229,0.512,3,1,0.4081,0.7705,0.4883,-0.0802,-0.0719,有向图求欧拉回路：. [.]
Aug 17 2018 22:06:37,87,42,82,102,1.25,0.968,0.957,0.957,4,1,0.0316,0.0433,0.0433,-0.0116,-0.0009,AVL
Aug 17 2018 22:07:28,143,14,2,1,0.5,0.95,0.896,0.896,2,0,0.9504,0.8956,0.8956,0.0548,0.1012,int gcd2 (int a_ int b) . { . [.]. }
Aug 17 2018 22:07:54,102,43,86,101,1.17,0.967,0.956,0.956,4,1,0.0326,0.0443,0.0443,-0.0117,-0.0009,AVL
Aug 17 2018 22:08:02,19,14,20,12,0.62,0.851,0.658,0.851,4,1,0.1488,0.3418,0.1493,-0.0005,-0.0001,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 17 2018 22:08:16,119,14,28,18,0.64,0.95,0.823,0.859,4,1,0.0495,0.1767,0.1411,-0.0916,-0.0175,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Aug 17 2018 22:08:25,123,14,25,12,0.48,0.951,0.841,0.589,4,1,0.0486,0.1594,0.4105,-0.362,-0.1662,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Aug 17 2018 22:08:32,115,48,98,239,2.44,0.913,0.959,0.985,4,1,0.0867,0.041,0.0149,0.0718,0.0073,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Aug 17 2018 22:08:51,46,62,85,173,2.03,0.746,0.924,0.969,4,1,0.2537,0.0763,0.0313,0.2224,0.0634,线段树build
Aug 17 2018 22:10:29,9,54,3,1,0.33,0.867,0.961,0.974,2,0,0.867,0.9613,0.9736,-0.1066,-0.1962,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 17 2018 22:11:05,107,43,83,101,1.22,0.966,0.956,0.956,4,1,0.0344,0.0443,0.0443,-0.0099,-0.0008,AVL
Aug 17 2018 22:12:17,79,14,25,12,0.48,0.951,0.84,0.589,4,1,0.0487,0.1595,0.4106,-0.362,-0.1663,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 17 2018 22:12:32,66,35,49,111,2.26,0.896,0.958,0.972,4,1,0.1041,0.0419,0.0285,0.0756,0.01,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Aug 17 2018 22:12:38,54,6,9,3,0.37,0.826,0.529,0.569,4,1,0.1741,0.471,0.4311,-0.2569,-0.1555,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Aug 17 2018 22:13:07,111,43,88,101,1.15,0.97,0.956,0.956,4,1,0.0304,0.0444,0.0444,-0.014,-0.001,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的[.]我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图： .
Aug 17 2018 22:13:13,47,62,123,173,1.4,0.852,0.924,0.969,4,1,0.148,0.0763,0.0313,0.1168,0.0209,线段树search
Aug 26 2018 15:01:29,132,33,3,2,0.55,0.907,0.933,0.933,2,0,0.9065,0.933,0.933,-0.0265,-0.0488,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Aug 26 2018 15:03:10,146,9,16,4,0.27,0.738,0.4,0.52,4,1,0.2623,0.6004,0.4798,-0.2175,-0.1614,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Aug 26 2018 15:03:43,143,9,15,5,0.31,0.685,0.4,0.599,4,1,0.3147,0.6004,0.4012,-0.0865,-0.0619,int gcd2 (int a_ int b) . { . [.]. }
Aug 26 2018 15:03:51,54,9,14,11,0.81,0.935,0.793,0.876,4,1,0.0648,0.2074,0.1244,-0.0596,-0.0113,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Aug 26 2018 15:05:32,14,69,101,237,2.35,0.867,0.962,0.974,4,1,0.1334,0.0378,0.0258,0.1075,0.0171,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
Aug 26 2018 15:05:46,116,57,95,225,2.37,0.841,0.954,0.981,4,1,0.1589,0.0463,0.0193,0.1395,0.0249,2.定理：. 1.[.]充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Aug 26 2018 15:05:57,121,23,48,13,0.27,0.921,0.766,0.603,4,1,0.0786,0.2336,0.3974,-0.3188,-0.1518,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Aug 26 2018 15:06:28,103,23,48,13,0.27,0.91,0.766,0.603,4,1,0.0903,0.2335,0.3974,-0.3071,-0.1498,快速幂
Aug 26 2018 15:06:46,113,48,118,116,0.98,0.967,0.957,0.957,5,1,0.0329,0.0433,0.0433,-0.0104,-0.0008,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的[.]我们称之为欧拉回路. 5.欧拉图： .
Aug 26 2018 15:06:53,10,69,102,237,2.32,0.867,0.962,0.974,5,1,0.1327,0.0377,0.0258,0.1069,0.017,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Aug 26 2018 15:07:13,31,74,3,1,0.35,0.728,0.862,0.862,2,0,0.7279,0.8616,0.8616,-0.1338,-0.2126,线段树updata
Aug 26 2018 15:07:47,9,9,3,1,0.33,0.709,0.4,0.649,2,0,0.7087,0.3996,0.6495,0.0592,0.0804,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 26 2018 15:07:55,125,33,53,63,1.19,0.902,0.916,0.945,4,1,0.0981,0.0841,0.0553,0.0428,0.0066,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Aug 26 2018 15:09:08,101,17,23,8,0.34,0.555,0.168,0.464,4,1,0.4448,0.8321,0.5362,-0.0914,-0.0897,修改距离动态规划
Aug 29 2018 18:10:39,132,3,5,3,0.54,0.895,0.719,0.773,4,1,0.1055,0.281,0.2266,-0.1211,-0.0402,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Aug 29 2018 18:10:43,31,3,5,3,0.55,0.894,0.719,0.779,4,1,0.1056,0.2807,0.2211,-0.1155,-0.0377,线段树updata
Aug 29 2018 18:10:50,9,3,5,6,1.15,0.894,0.855,0.854,4,1,0.1058,0.1453,0.1458,-0.04,-0.0101,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Aug 29 2018 18:11:15,91,60,88,186,2.12,0.848,0.959,0.971,4,1,0.1522,0.0415,0.029,0.1232,0.0223,KMP算法
Aug 29 2018 18:11:33,42,54,72,134,1.86,0.83,0.908,0.908,4,1,0.1703,0.092,0.092,0.0783,0.0205,完全背包模板
Aug 29 2018 18:11:51,83,67,90,229,2.55,0.758,0.899,0.976,4,1,0.2425,0.1013,0.0243,0.2182,0.0582,删除替换点
Aug 31 2018 22:48:43,139,22,32,35,1.09,0.906,0.923,0.939,4,1,0.0945,0.0775,0.0614,0.0331,0.0052,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Aug 31 2018 22:48:49,112,49,86,132,1.54,0.961,0.961,0.961,4,1,0.0389,0.0389,0.0389,0,0,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. [.]. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. 具有欧拉回路的图称之为欧拉图，规定平凡图（只有一个顶点的空图）属于欧拉图. 6.半欧拉图： .
Aug 31 2018 22:48:52,114,49,109,132,1.21,0.963,0.961,0.961,5,1,0.0367,0.0389,0.0389,-0.0022,-0.0002,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. [ .
Sep 02 2018 12:47:30,69,37,46,99,2.16,0.837,0.935,0.948,4,1,0.1631,0.0651,0.0517,0.1113,0.0239,3
Sep 20 2018 18:10:12,132,22,32,18,0.58,0.565,0.438,0.855,4,1,0.435,0.5621,0.1454,0.2896,0.1681,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Sep 20 2018 18:12:34,146,25,38,21,0.56,0.829,0.573,0.864,4,1,0.171,0.4267,0.1356,0.0354,0.0109,char* convertToTitle(int n) {.     n -= 1;.     char alp[27] = _ABCDEFGHIJKLMNOPQRSTUVWXYZ_;.     char *a = (char *)malloc(sizeof(char) * 20);.     char *b = (char .
Sep 20 2018 18:12:45,148,56,118,106,0.89,0.939,0.943,0.943,5,1,0.0612,0.0566,0.0566,0.0047,0.0006,【?】我们假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。
Sep 20 2018 18:13:56,143,25,2,1,0.5,0.807,0.573,0.864,2,0,0.8069,0.5732,0.8644,-0.0575,-0.0961,int gcd2 (int a_ int b) . { . [.]. }
Sep 20 2018 18:14:20,100,58,3,1,0.33,0.841,0.927,0.951,2,0,0.8413,0.9266,0.9515,-0.1102,-0.1975,修改距离动态规划
Sep 20 2018 18:14:27,108,74,106,374,3.53,0.761,0.945,0.987,5,1,0.2386,0.0546,0.0135,0.2251,0.0567,AVL
Sep 20 2018 18:15:01,101,25,35,14,0.4,0.891,0.729,0.69,4,1,0.1091,0.2708,0.3103,-0.2012,-0.0844,修改距离动态规划
Sep 20 2018 18:15:18,133,40,52,167,3.21,0.83,0.958,0.981,4,1,0.17,0.0418,0.0185,0.1515,0.0286,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Sep 20 2018 18:15:48,9,22,31,21,0.67,0.553,0.626,0.881,4,1,0.4472,0.3736,0.1194,0.3278,0.1857,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Sep 20 2018 18:16:35,129,34,41,17,0.41,0.812,0.613,0.687,3,1,0.1884,0.3873,0.3129,-0.1245,-0.0624,有向图求欧拉回路：. [.]
Sep 20 2018 18:16:51,31,22,31,21,0.67,0.558,0.438,0.876,4,1,0.4419,0.5623,0.1236,0.3183,0.18,线段树updata
Sep 20 2018 18:17:05,119,34,54,17,0.32,0.855,0.734,0.642,4,1,0.1446,0.266,0.3582,-0.2136,-0.1074,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Sep 20 2018 18:18:14,85,76,3,1,0.33,0.818,0.951,0.972,2,0,0.8182,0.9509,0.972,-0.1537,-0.2752,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Sep 20 2018 18:18:48,19,34,54,20,0.38,0.856,0.791,0.623,4,1,0.1444,0.2091,0.3775,-0.2331,-0.1216,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Sep 20 2018 18:19:17,123,34,2,1,0.5,0.829,0.898,0.914,2,0,0.8293,0.8982,0.9136,-0.0843,-0.1469,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Sep 20 2018 18:21:44,79,34,43,49,1.13,0.829,0.862,0.876,3,1,0.1712,0.1381,0.1239,0.0474,0.014,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Sep 20 2018 18:21:55,34,58,95,120,1.26,0.88,0.92,0.92,4,1,0.1197,0.0797,0.0797,0.04,0.008,01二维
Sep 20 2018 18:22:01,59,94,135,254,1.88,0.756,0.915,0.968,5,1,0.2435,0.0845,0.0315,0.212,0.0583,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
Sep 20 2018 18:22:36,36,48,87,91,1.04,0.925,0.927,0.927,4,1,0.0746,0.0725,0.0725,0.002,0.0003,01一维
Sep 20 2018 18:22:42,54,25,3,1,0.33,0.79,0.803,0.629,2,0,0.79,0.8026,0.6289,0.1611,0.2286,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Sep 20 2018 18:23:00,20,96,132,240,1.82,0.791,0.945,0.966,4,1,0.209,0.0549,0.0342,0.1748,0.0425,状态压缩
Oct 15 2018 20:42:16,139,45,3,9,3,0.889,0.91,0.91,2,0,0.8889,0.9103,0.9103,-0.0214,-0.0385,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Oct 15 2018 20:42:32,143,25,2,1,0.5,0.288,0.071,0.506,2,0,0.2878,0.071,0.5058,-0.218,-0.173,int gcd2 (int a_ int b) . { . [.]. }
Oct 15 2018 20:42:42,122,92,146,265,1.81,0.818,0.911,0.967,5,1,0.1818,0.0892,0.0331,0.1487,0.0319,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.[.]的充分必要条件是图是强连通，并且每个定点的入度等于出度 .
Oct 15 2018 20:42:52,60,106,142,288,2.03,0.756,0.907,0.959,5,1,0.2441,0.0928,0.0411,0.203,0.0579,黑高
Oct 15 2018 20:43:07,93,107,137,322,2.35,0.585,0.889,0.956,4,1,0.4146,0.111,0.0441,0.3706,0.17,图割点
Oct 15 2018 20:44:49,85,25,3,3,1.02,0.377,0.292,0.897,1,0,0.3771,0.2922,0.8966,-0.5195,-0.6617,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Oct 15 2018 20:45:00,100,25,34,14,0.41,0.37,0.071,0.649,5,1,0.6298,0.929,0.3514,0.2783,0.2731,修改距离动态规划
Oct 15 2018 20:45:14,150,100,160,409,2.56,0.542,0.854,0.967,4,1,0.4583,0.1458,0.0332,0.4251,0.2089,public class Solution { .     /* .     http://www.programcreek.com/2014/02/leetcode-majority-element-java/ .     */ .     public int majorityElement(int[] nums) { .
Oct 15 2018 20:47:13,82,99,3,1,0.33,0.745,0.887,0.897,2,0,0.7448,0.8867,0.897,-0.1522,-0.2499,找到替换点
Oct 15 2018 20:47:45,35,110,3,1,0.33,0.751,0.946,0.946,2,0,0.7513,0.9464,0.9464,-0.1951,-0.3312,01二维
Oct 15 2018 20:48:10,103,50,98,108,1.1,0.905,0.948,0.955,4,1,0.0955,0.0524,0.0451,0.0504,0.0071,快速幂
Oct 15 2018 20:48:27,73,97,124,226,1.82,0.801,0.943,0.963,3,1,0.1991,0.0575,0.037,0.1622,0.0383,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Oct 15 2018 20:48:33,44,108,171,255,1.49,0.811,0.926,0.926,4,1,0.1895,0.0736,0.0736,0.1158,0.0305,线段树pushUp
Oct 15 2018 20:49:12,45,70,3,2,0.56,0.87,0.93,0.954,2,0,0.8698,0.9301,0.9537,-0.0839,-0.1529,4
Oct 15 2018 20:49:21,27,102,149,232,1.55,0.818,0.934,0.934,4,1,0.1821,0.066,0.066,0.1161,0.0288,01二维
Oct 15 2018 20:49:27,54,25,30,11,0.37,0.382,0.071,0.41,4,1,0.6184,0.929,0.59,0.0284,0.0343,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Oct 15 2018 20:49:33,56,121,180,406,2.26,0.695,0.905,0.98,5,1,0.3046,0.0947,0.0196,0.285,0.0924,平衡性
Oct 15 2018 20:49:40,11,106,155,262,1.69,0.777,0.917,0.966,5,1,0.2228,0.0835,0.0339,0.1889,0.0485,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Oct 15 2018 20:50:03,58,121,3,9,3,0.647,0.905,0.981,2,0,0.6472,0.9054,0.9811,-0.3339,-0.5436,性质
Oct 15 2018 20:50:27,147,83,143,408,2.85,0.819,0.94,0.986,5,1,0.1813,0.0605,0.0136,0.1677,0.0327,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while([.]).     {.         if(mid*mid > xx){ .
Oct 15 2018 20:52:38,24,124,178,409,2.3,0.689,0.884,0.978,3,1,0.3107,0.1159,0.0222,0.2884,0.096,状态压缩
Oct 15 2018 20:52:56,121,50,3,2,0.76,0.896,0.887,0.887,2,0,0.8962,0.887,0.887,0.0091,0.0163,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Oct 15 2018 20:53:11,57,121,192,429,2.24,0.708,0.905,0.982,4,1,0.2918,0.0948,0.0184,0.2735,0.0848,结点属性
Oct 15 2018 20:53:33,12,118,3,1,0.33,0.77,0.935,0.935,2,0,0.7698,0.9351,0.9351,-0.1653,-0.2818,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Oct 15 2018 20:53:41,123,25,31,27,0.86,0.338,0.348,0.895,3,1,0.6619,0.6521,0.1047,0.5572,0.4271,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3.有向图G是欧拉图的充分必要条件是[.]4 .
Oct 18 2018 12:33:19,132,28,3,1,0.33,0.951,0.939,0.981,2,0,0.9514,0.9388,0.9814,-0.0301,-0.0581,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Oct 18 2018 12:33:42,143,3,4,5,1.13,0.864,0.837,0.846,4,1,0.1365,0.1626,0.1538,-0.0173,-0.005,int gcd2 (int a_ int b) . { . [.]. }
Oct 18 2018 12:33:46,12,3,5,3,0.58,0.9,0.756,0.815,5,1,0.1,0.2438,0.1849,-0.085,-0.0242,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Oct 18 2018 12:33:51,121,3,5,3,0.6,0.895,0.756,0.824,4,1,0.1052,0.2439,0.1763,-0.0712,-0.02,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
Oct 18 2018 12:34:15,45,3,5,3,0.61,0.895,0.756,0.827,3,1,0.1049,0.2441,0.1726,-0.0677,-0.0188,4
Oct 18 2018 12:34:25,31,28,3,1,0.33,0.951,0.879,0.965,2,0,0.9512,0.8793,0.965,-0.0138,-0.0264,线段树updata
Oct 18 2018 12:35:12,138,76,131,291,2.22,0.812,0.892,0.974,4,1,0.1877,0.1076,0.0255,0.1622,0.0346,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 状态转移： . [.]
Oct 18 2018 12:35:35,9,28,3,1,0.5,0.951,0.88,0.967,2,0,0.9512,0.8799,0.9672,-0.016,-0.0307,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Oct 18 2018 12:36:28,16,100,3,2,0.59,0.785,0.955,0.976,2,0,0.7849,0.9546,0.976,-0.1911,-0.3365,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
Oct 18 2018 12:37:06,85,3,3,1,0.33,0.894,0.881,0.886,2,0,0.8945,0.8807,0.8864,0.008,0.0143,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Oct 18 2018 12:37:19,82,3,5,3,0.58,0.9,0.756,0.813,5,1,0.1004,0.2444,0.1868,-0.0864,-0.0248,找到替换点
Oct 18 2018 12:37:32,35,3,5,5,1.08,0.899,0.92,0.886,4,1,0.1007,0.0796,0.1139,-0.0132,-0.0028,01二维
Oct 19 2018 15:34:11,132,1,2,1,0.5,0.961,0.888,0.88,2,0,0.9607,0.8882,0.8805,0.0802,0.1477,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Oct 19 2018 15:34:18,117,98,3,9,3,0.797,0.905,0.982,2,0,0.7971,0.9049,0.9821,-0.185,-0.3292,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Oct 19 2018 15:34:30,9,1,2,2,1.18,0.961,0.888,0.852,5,1,0.0393,0.1117,0.1482,-0.1089,-0.0204,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Oct 19 2018 15:34:34,31,1,2,2,1.21,0.961,0.888,0.858,5,1,0.0394,0.1118,0.1424,-0.103,-0.0187,线段树updata
Oct 19 2018 15:34:44,85,1,2,3,1.61,0.961,0.968,0.886,5,1,0.0394,0.0319,0.1143,-0.0749,-0.0115,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Mar 08 2019 15:22:24,90,227,3,9,3,0.484,0.901,0.92,2,0,0.4844,0.9013,0.9196,-0.4353,-0.6111,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. DP解法： . 状态： . [.]
Mar 08 2019 15:26:05,132,140,2,3,1.69,0.005,0.005,0.869,1,0,0.005,0.0052,0.869,-0.864,-0.7552,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Mar 08 2019 15:29:50,139,144,3,1,0.33,0.005,0.000,0.539,2,0,0.005,0.0003,0.5392,-0.5342,-0.2908,【DP】放苹果问题. M个相同的苹果，N个相同的的盘子，允许盘子为空，且不能重复，如（5，1，1）与（1，1，5）视为同一种放法。问共有多少种放法？. 代码. def putApple(m_n):. [.]
Mar 08 2019 15:35:02,63,227,3,1,0.33,0.626,0.929,0.945,1,0,0.6257,0.9288,0.9454,-0.3197,-0.5022,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
Mar 08 2019 15:35:16,54,144,3,1,0.33,0.604,0.269,0.925,2,0,0.6039,0.269,0.9254,-0.3215,-0.4917,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
Mar 08 2019 15:35:41,118,217,290,737,2.54,0.659,0.849,0.951,4,1,0.3413,0.1511,0.0495,0.2918,0.114,int mySqrt(int x) {.     double xx = x;.     double low = 0_high = x_mid = (low + high)/2;.     if(x == 1)return 1;.     while(mid*mid - xx > 0.001 || mid*mid - xx < -0.001) .
Mar 08 2019 15:36:25,119,169,3,1,0.33,0.685,0.848,0.848,2,0,0.6852,0.8477,0.8477,-0.1624,-0.249,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.[.]充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Mar 08 2019 15:37:29,94,215,286,671,2.35,0.578,0.804,0.968,4,1,0.422,0.1959,0.0323,0.3898,0.1771,图割点
Mar 08 2019 15:40:03,124,224,3,4,1.25,0.637,0.815,0.898,2,0,0.6366,0.8147,0.8979,-0.2613,-0.401,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Mar 08 2019 15:40:51,148,169,255,380,1.49,0.826,0.928,0.945,4,1,0.1739,0.0717,0.0552,0.1187,0.0272,【?】我们假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。
Mar 08 2019 15:41:04,95,227,293,291,0.99,0.517,0.792,0.859,4,1,0.4825,0.2079,0.1409,0.3416,0.213,图割点
Mar 08 2019 15:41:31,21,227,3,9,3,0.679,0.895,0.895,2,0,0.6787,0.8951,0.8951,-0.2164,-0.3406,红黑树旋转
Mar 08 2019 15:42:10,117,140,3,2,0.52,0.005,0,0.479,2,0,0.005,0,0.4787,-0.4737,-0.2292,2.定理：. 1.无向图G是欧拉图的充分必要条件是[.]. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 必要性：图G是半欧拉图，证明G中恰好有两个奇数度的顶点. G是半欧拉图，存在一条欧拉通路――通路上非端点节点必然是偶数度的――通路上的两个端点，必然都是奇数度 .
Mar 08 2019 15:43:49,129,169,3,4,1.26,0.647,0.903,0.903,2,0,0.6468,0.903,0.903,-0.2562,-0.397,有向图求欧拉回路：. [.]
Mar 08 2019 15:46:39,125,194,3,8,2.82,0.62,0.792,0.859,2,0,0.6199,0.792,0.8591,-0.2391,-0.3537,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，假设半欧拉图中有2*k个边，我们最少需要k笔才可以画完这个半欧拉图。. 3 .
Mar 08 2019 15:47:00,89,217,277,526,1.9,0.673,0.912,0.961,4,1,0.3274,0.0876,0.039,0.2884,0.1057,typedef struct RBtree. {. [红黑树的结构定义]. } rbtree;
Mar 08 2019 15:53:18,85,140,2,1,0.5,0.005,0.004,0.873,2,0,0.005,0.0043,0.8733,-0.8683,-0.7627,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Mar 08 2019 15:54:09,58,144,174,62,0.35,0.014,0,0.428,4,1,0.9863,1,0.5717,0.4146,0.6459,性质
Mar 08 2019 15:56:19,84,227,4,9,2.25,0.522,0.858,0.872,1,0,0.5222,0.8578,0.8719,-0.3497,-0.4875,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Mar 08 2019 15:57:05,19,169,3,1,0.42,0.678,0.901,0.901,1,0,0.6776,0.901,0.901,-0.2234,-0.3527,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Mar 08 2019 16:01:53,103,144,3,1,0.33,0.811,0.886,0.924,2,0,0.811,0.8864,0.9241,-0.1131,-0.1962,快速幂
Mar 08 2019 16:03:21,101,169,215,352,1.64,0.573,0.856,0.903,4,1,0.4268,0.1442,0.097,0.3298,0.1728,修改距离动态规划
Mar 08 2019 16:04:16,114,189,269,501,1.86,0.768,0.932,0.972,4,1,0.2318,0.0684,0.0284,0.2035,0.0529,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. [ .
Mar 08 2019 16:04:51,143,141,172,128,0.74,0.017,0.005,0.878,4,1,0.9831,0.9951,0.1225,0.8606,0.9515,int gcd2 (int a_ int b) . { . [.]. }
Mar 08 2019 16:06:12,91,191,4,1,0.25,0.78,0.884,0.884,2,0,0.78,0.8838,0.8838,-0.1038,-0.1728,KMP算法
Mar 08 2019 16:23:23,68,209,4,9,2.25,0.658,0.908,0.908,2,0,0.6583,0.9082,0.9082,-0.2499,-0.3915,1
Mar 08 2019 16:23:34,112,189,4,2,0.57,0.73,0.932,0.974,2,0,0.7301,0.9316,0.9739,-0.2437,-0.4153,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. [.]. 4.欧拉回路：. 如果我们的欧拉通路的起点和终点是一样的我们称之为欧拉回路. 5.欧拉图：. 具有欧拉回路的图称之为欧拉图，规定平凡图（只有一个顶点的空图）属于欧拉图. 6.半欧拉图： .
Mar 08 2019 16:23:47,140,215,3,7,2.38,0.549,0.804,0.97,2,0,0.5495,0.8041,0.9698,-0.4203,-0.6386,int gcd(int a_int b). {. [.]. }
Mar 08 2019 16:26:44,82,141,3,1,0.33,0.018,0.005,0.878,2,0,0.0177,0.0049,0.8775,-0.8598,-0.7697,找到替换点
Mar 08 2019 16:26:57,100,144,179,172,0.96,0.613,0.268,0.929,4,1,0.3871,0.7322,0.0711,0.316,0.1448,修改距离动态规划
Mar 08 2019 16:27:39,113,194,266,544,2.05,0.747,0.931,0.974,5,1,0.2528,0.0688,0.0263,0.2265,0.0632,1.定义：. 1.我们的定义的数据对象的范围是有向图和无向图. 2.图的通路：. 图中的顶点与边的交替序列我们称之为是图的通路. 3.欧拉通路：. 我们从有向图或者无向图中的任意一点出发，将所有的边遍历且仅遍历一次的通路序列我们称之为是欧拉通路. 4.欧拉回路：. 如果我们的欧拉通路的[.]我们称之为欧拉回路. 5.欧拉图： .
Mar 08 2019 16:28:21,133,169,3,1,0.33,0.709,0.916,0.916,2,0,0.7091,0.9163,0.9163,-0.2072,-0.3367,伪代码可能较为难懂，以通俗的语言描述就是随机选取v0作为欧拉回路的起点，v0入栈，按顺序选取与v0关联的点v1，v1入栈，删除v0----v1边，再选择与v1相关联的点，直到Vn，若无与Vn相关联的边则判断回路的边数是否 等于图的边数，若相等则算法结束，否则Vn出栈，选择V（n-1）的另一条边。. public void euler(int[][] .
Mar 08 2019 16:29:32,46,203,259,673,2.6,0.765,0.939,0.978,4,1,0.2345,0.0608,0.022,0.2125,0.0545,线段树build
Mar 08 2019 16:33:08,66,203,3,5,1.55,0.617,0.877,0.877,2,0,0.6174,0.8774,0.8774,-0.2601,-0.3888,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Mar 08 2019 16:34:15,107,203,4,2,0.59,0.677,0.921,0.974,2,0,0.6767,0.9206,0.9742,-0.2975,-0.4912,AVL
Mar 08 2019 16:36:58,65,236,3,9,3,0.433,0.894,0.961,2,0,0.4332,0.8941,0.9614,-0.5281,-0.7365,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
Mar 08 2019 16:37:58,62,237,3,1,0.33,0.545,0.834,0.974,2,0,0.5451,0.8338,0.9737,-0.4286,-0.6509,2
Mar 08 2019 16:38:10,121,141,3,1,0.47,0.018,0.005,0.881,2,0,0.0182,0.0049,0.8814,-0.8632,-0.7765,2.定理：. 1.无向图G是欧拉图的充分必要条件是G 是连通图并且没有奇数度顶点. 2.无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点. 定理2拓展，如果我们想要一笔画完一个半欧拉图我们，[.]3.有向图G是欧拉图的充分必要条件是图是强连通，并且每个定点的入度等于出度. 4 .
