Date, Element No, Used interval, SM16 Interval (new), SM17 Interval (new), SM17/SM16 Interval ratio, R (SM16), R (SM17)(exp), R (SM17), Grade, Success, abs RM16, abs RM17 (expected), abs RM17 (predicted), abs R-Metric, sqr R-Metric, Title,
May 10 2018 07:03:01,41,4,2,1,0.5,0.817,0.889,0.917,2,0,0.8171,0.8894,0.9168,-0.0996,-0.1727,完全背包模板
May 10 2018 07:03:21,23,19,2,1,0.5,0.288,0.521,0.806,1,0,0.2884,0.5207,0.8056,-0.5172,-0.5659,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:04,42,5,17,22,1.28,0.714,0.858,0.898,4,1,0.2855,0.1424,0.1015,0.184,0.0712,完全背包模板
May 11 2018 08:00:25,41,1,2,7,3.4,0.951,0.896,0.896,4,1,0.0489,0.1038,0.1038,-0.0549,-0.0084,完全背包模板
May 11 2018 08:00:33,23,1,2,7,3.4,0.956,0.896,0.896,4,1,0.0444,0.1038,0.1038,-0.0594,-0.0088,5.一定要注意的问题：. 原数组，存储所有子集的数组，还有用来存储任意个数二进制个数的数组大小都要开到[.]次方。另，当n <= 20时，时间空间都可以容纳2^20
May 11 2018 08:00:50,27,5,15,22,1.46,0.799,0.857,0.898,4,1,0.2013,0.1433,0.1015,0.0998,0.0302,01二维
May 11 2018 08:01:07,12,11,28,26,0.92,0.98,0.95,0.95,4,1,0.0201,0.0503,0.0503,-0.0301,-0.0021,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 12 2018 09:10:30,30,6,2,1,0.5,0.755,0.826,0.885,2,0,0.7553,0.8262,0.8846,-0.1292,-0.2119,01一维
May 12 2018 09:10:36,21,21,58,29,0.49,0.406,0.484,0.8,4,1,0.5939,0.5162,0.2,0.394,0.3128,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 13 2018 08:22:59,30,1,2,6,3.14,0.959,0.903,0.903,4,1,0.041,0.0969,0.0969,-0.0559,-0.0077,01一维
May 15 2018 09:11:00,10,25,62,33,0.54,0.426,0.424,0.8,4,1,0.5743,0.5761,0.2,0.3744,0.2899,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:11:39,42,4,3,1,0.33,0.985,0.971,0.971,2,0,0.9853,0.9709,0.9709,0.0144,0.0282,完全背包模板
May 15 2018 09:12:20,18,24,63,32,0.51,0.481,0.435,0.8,3,1,0.5191,0.5646,0.2,0.3191,0.2295,1.(k&-k)在状态压缩和树状数组中都经常能够看到，那么（k&-k）的值是什么含义呢？. 这个值是把k的二进制的高位1全部清空，只留下最低位的1，当然如果只有一位1，则保留等于k本身。该操作就是留下k二进制数中最低位的一个1. 2.两种相等的形式：i-(i&-i) = i^(i&-i). 他们都表示减去最低位的1，再返回值. 3 .
May 15 2018 09:13:15,14,25,68,33,0.49,0.5,0.424,0.8,3,1,0.5,0.5759,0.2,0.3,0.21,树状数组区间查询. ok 下面利用C[i]数组，求A数组中前i项的和 . 举个例子 i=7;. sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;   前i项和. C[4]=A[1]+A[2]+A[3]+A[4];   C[6]=A[5]+A[6];   C[7]=A[7];. 可以推出 .
May 15 2018 09:13:36,44,3,13,11,0.83,0.919,0.917,0.943,4,1,0.0806,0.0827,0.0568,0.0237,0.0033,线段树pushUp
May 15 2018 09:14:48,66,1,3,1,0.33,0.972,0.98,0.99,2,0,0.9718,0.9805,0.99,-0.0182,-0.0358,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:15:31,34,9,25,18,0.71,0.775,0.743,0.856,3,1,0.2247,0.257,0.1441,0.0806,0.0297,01二维
May 15 2018 09:16:23,12,4,27,35,1.29,0.99,0.987,0.987,3,1,0.0098,0.0126,0.0126,-0.0028,-0.0001,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:16:36,54,1,17,5,0.32,0.972,0.979,0.99,4,1,0.0281,0.021,0.01,0.0182,0.0007,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 15 2018 09:16:48,57,1,30,8,0.28,0.972,0.963,0.99,4,1,0.0283,0.0369,0.01,0.0184,0.0007,结点属性
May 15 2018 09:17:42,23,4,8,14,1.78,0.839,0.929,0.929,3,1,0.161,0.0715,0.0715,0.0896,0.0208,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 15 2018 09:18:23,27,4,23,15,0.67,0.983,0.971,0.971,3,1,0.0174,0.0291,0.0291,-0.0117,-0.0005,01二维
May 15 2018 09:18:41,60,1,3,1,0.33,0.971,0.963,0.99,2,0,0.9711,0.9631,0.99,-0.0189,-0.0371,黑高
May 15 2018 09:21:43,40,9,30,18,0.59,0.771,0.744,0.856,4,1,0.2288,0.2563,0.1441,0.0847,0.0316,完全背包模板
May 15 2018 09:22:24,38,9,20,18,0.88,0.774,0.743,0.856,3,1,0.2259,0.2566,0.1441,0.0818,0.0303,01一维
May 15 2018 09:22:52,35,9,40,18,0.44,0.777,0.743,0.856,4,1,0.2229,0.2571,0.1441,0.0788,0.0289,01二维
May 15 2018 09:23:32,20,24,63,32,0.51,0.542,0.435,0.8,4,1,0.458,0.5647,0.2,0.258,0.1697,状态压缩
May 15 2018 09:23:52,56,1,5,8,1.69,0.975,0.963,0.99,4,1,0.0253,0.0371,0.01,0.0153,0.0005,平衡性
May 15 2018 09:29:39,11,25,4,1,0.25,0.504,0.424,0.8,2,0,0.5036,0.4238,0.8,-0.2964,-0.3864,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 15 2018 09:31:48,33,9,23,18,0.77,0.783,0.743,0.856,4,1,0.2165,0.2573,0.1441,0.0725,0.0261,01二维
May 15 2018 09:32:26,25,24,64,32,0.51,0.547,0.435,0.8,3,1,0.4527,0.5647,0.2,0.2527,0.165,状态压缩
May 15 2018 09:32:44,29,3,26,11,0.42,0.927,0.917,0.943,4,1,0.0727,0.0831,0.0568,0.0159,0.0021,线段树类型定义
May 15 2018 09:33:10,50,3,30,11,0.36,0.927,0.917,0.943,4,1,0.0728,0.0831,0.0568,0.0159,0.0021,线段树add
May 15 2018 09:33:38,41,4,9,14,1.59,0.839,0.928,0.928,4,1,0.161,0.0716,0.0716,0.0894,0.0208,完全背包模板
May 15 2018 09:34:08,58,1,32,8,0.27,0.975,0.963,0.99,4,1,0.0249,0.0373,0.01,0.015,0.0005,性质
May 15 2018 09:35:57,63,1,11,5,0.5,0.975,0.979,0.99,3,1,0.025,0.0214,0.01,0.015,0.0005,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 15 2018 09:36:29,36,9,4,1,0.25,0.787,0.743,0.856,2,0,0.7869,0.7431,0.8559,-0.0691,-0.1135,01一维
May 15 2018 09:36:59,24,24,3,1,0.33,0.504,0.435,0.8,2,0,0.504,0.4352,0.8,-0.296,-0.386,状态压缩
May 15 2018 09:37:22,59,1,9,9,0.95,0.972,0.963,0.99,4,1,0.0282,0.0374,0.01,0.0183,0.0007,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 15 2018 09:39:00,30,2,6,6,1.08,0.916,0.961,0.961,4,1,0.0841,0.0389,0.0389,0.0451,0.0056,01一维
May 15 2018 09:40:03,15,18,44,54,1.22,0.954,0.884,0.884,4,1,0.0464,0.1162,0.1162,-0.0698,-0.0113,*************************************************分割线. 单点更新. 当我们修改A[]数组中的某一个值时  应当如何更新C[]数组呢？. 回想一下 区间查询的过程，再看一下上文中列出的图. 结合代码分析. void add(int x_int y) . { . for(int .
May 15 2018 09:41:01,65,1,25,5,0.21,0.972,0.98,0.99,4,1,0.0283,0.0201,0.01,0.0184,0.0007,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 15 2018 09:41:05,7,19,40,86,2.15,0.883,0.881,0.881,4,1,0.1167,0.1189,0.1189,-0.0022,-0.0005,树状数组彻底入门int lowbit(int t) . { . [.] . }. void add(int x_int y) . { . for(int i=x;i<=n;i+=lowbit(i)) . tree[i]+=y; . }. int getsum(int x) . { . int ans=0; . for(int i=x;i>0;i .
May 15 2018 09:42:34,16,20,51,57,1.11,0.929,0.864,0.864,4,1,0.0713,0.1364,0.1364,-0.0651,-0.0135,树状数组彻底入门int lowbit(int t) . { . return t&(-t); . }. [.].      这篇笔记 会详细的讲解，使得队员们对树状数组彻底入门  而不是懵懵懂懂。. 以上先给出 最常见的，三个函数。(单点更新，区间查询).      网上的解释以及分析有很多，这里是我的一点总结和体会归纳一下，并且在周三(2016 .
May 16 2018 06:53:11,66,1,2,6,2.81,0.97,0.909,0.909,3,1,0.0298,0.0906,0.0906,-0.0608,-0.0073,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 16 2018 06:53:33,60,1,2,6,2.8,0.971,0.91,0.91,4,1,0.029,0.0904,0.0904,-0.0614,-0.0073,黑高
May 16 2018 06:53:41,11,1,2,6,2.76,0.972,0.91,0.91,4,1,0.0282,0.0897,0.0897,-0.0615,-0.0072,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 16 2018 06:53:51,42,1,2,2,1.13,0.973,0.909,0.909,4,1,0.0274,0.0909,0.0909,-0.0635,-0.0075,完全背包模板
May 16 2018 06:54:07,36,1,2,5,2.74,0.973,0.911,0.911,4,1,0.0267,0.0892,0.0892,-0.0626,-0.0073,01一维
May 16 2018 06:54:15,24,1,2,5,2.74,0.974,0.911,0.911,5,1,0.026,0.0892,0.0892,-0.0632,-0.0073,状态压缩
May 18 2018 07:33:12,46,3,6,12,2.01,0.931,0.925,0.917,4,1,0.0694,0.0749,0.0832,-0.0138,-0.0021,线段树build
May 18 2018 07:34:04,47,3,6,12,2.01,0.93,0.925,0.917,4,1,0.0697,0.0749,0.0832,-0.0135,-0.0021,线段树search
May 18 2018 07:35:06,49,3,4,1,0.25,0.929,0.925,0.917,2,0,0.9289,0.925,0.9168,0.0121,0.0224,线段树pushDown
May 18 2018 07:35:31,31,3,4,1,0.25,0.927,0.925,0.917,2,0,0.9274,0.9246,0.9168,0.0106,0.0196,线段树updata
May 18 2018 07:35:54,42,2,4,5,1.13,0.943,0.903,0.903,4,1,0.0569,0.097,0.097,-0.0401,-0.0062,完全背包模板
May 19 2018 09:37:55,49,1,2,7,3.5,0.973,0.892,0.892,4,1,0.0266,0.1081,0.1081,-0.0815,-0.011,线段树pushDown
May 19 2018 09:38:08,31,1,2,7,3.5,0.974,0.892,0.892,3,1,0.026,0.108,0.108,-0.0821,-0.011,线段树updata
May 20 2018 07:34:52,84,3,5,12,2.48,0.931,0.91,0.917,3,1,0.0694,0.0896,0.0832,-0.0139,-0.0021,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
May 20 2018 07:36:08,79,2,4,7,1.65,0.953,0.954,0.943,4,1,0.047,0.0458,0.0568,-0.0098,-0.001,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:37:20,68,3,6,9,1.54,0.93,0.936,0.943,4,1,0.07,0.0636,0.0568,0.0131,0.0017,1
May 20 2018 07:37:39,62,3,4,1,0.25,0.929,0.936,0.943,2,0,0.9285,0.9364,0.9432,-0.0147,-0.0274,2
May 20 2018 07:38:08,19,3,6,9,1.51,0.928,0.938,0.943,4,1,0.0717,0.0622,0.0568,0.0149,0.0019,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 20 2018 07:39:11,63,3,5,23,4.64,0.928,0.994,0.943,3,1,0.072,0.0062,0.0568,0.0151,0.0019,由于这两个操作对树做了修改，结果可能违反13.1节中列出的红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。.     指针结构的修改是通过旋转 ( ratation )来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。图 13-2中给出了两种旋转：左旋和右旋。当在某个结点x上做左旋时，假设它的右孩子为y而不是 T.nil .
May 20 2018 07:40:50,65,5,4,1,0.25,0.823,0.964,0.964,2,0,0.8227,0.9638,0.9638,-0.141,-0.2519,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 20 2018 07:40:59,54,5,12,15,1.26,0.823,0.964,0.964,4,1,0.1773,0.0363,0.0363,0.141,0.0301,搜索树操作TREE - INSERT 和TREE - DELETE 在含n个关键字的红黑树上，运行花费时间为[.]
May 20 2018 07:42:15,69,3,5,9,1.85,0.928,0.936,0.943,3,1,0.0721,0.0637,0.0568,0.0153,0.002,3
May 20 2018 07:42:29,45,3,6,9,1.53,0.928,0.937,0.943,4,1,0.0724,0.0631,0.0568,0.0155,0.002,4
May 20 2018 07:42:55,21,4,9,18,2.05,0.907,0.885,0.917,4,1,0.0927,0.1147,0.0832,0.0095,0.0017,红黑树旋转
May 21 2018 07:01:51,30,6,11,29,2.6,0.86,0.928,0.928,4,1,0.1397,0.0721,0.0721,0.0676,0.0143,01一维
May 21 2018 07:02:20,65,1,2,3,1.25,0.974,0.903,0.903,4,1,0.0259,0.0975,0.0975,-0.0716,-0.0088,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 21 2018 07:02:35,36,5,12,22,1.8,0.803,0.903,0.903,4,1,0.1971,0.0968,0.0968,0.1003,0.0295,01一维
May 21 2018 07:02:42,24,5,12,22,1.8,0.823,0.903,0.903,4,1,0.1773,0.0968,0.0968,0.0805,0.0221,状态压缩
May 21 2018 07:03:24,62,1,2,6,3.19,0.975,0.902,0.902,4,1,0.0254,0.0977,0.0977,-0.0724,-0.0089,2
May 22 2018 08:29:45,66,6,15,24,1.62,0.74,0.885,0.885,4,1,0.2599,0.1151,0.1151,0.1449,0.0543,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 22 2018 08:30:03,60,6,10,24,2.42,0.74,0.885,0.885,3,1,0.2599,0.1152,0.1152,0.1447,0.0543,黑高
May 22 2018 08:30:18,11,6,16,24,1.51,0.768,0.884,0.884,4,1,0.2316,0.1157,0.1157,0.1158,0.0402,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
May 23 2018 06:47:21,57,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2122,0.0688,结点属性
May 23 2018 06:47:51,58,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0558,0.0558,0.2123,0.0688,性质
May 23 2018 06:48:18,42,5,10,7,0.74,0.907,0.84,0.84,4,1,0.0929,0.1598,0.1598,-0.0669,-0.0169,完全背包模板
May 23 2018 06:48:26,56,8,22,22,1.02,0.732,0.944,0.944,4,1,0.2681,0.0559,0.0559,0.2123,0.0688,平衡性
May 24 2018 07:25:49,65,3,6,6,0.93,0.877,0.863,0.863,4,1,0.1234,0.1367,0.1367,-0.0133,-0.0035,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 24 2018 07:25:56,59,9,24,25,1.06,0.704,0.937,0.937,4,1,0.2962,0.0629,0.0629,0.2333,0.0838,为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL (参见10.2节）。对于一棵红黑树 T _ 哨兵 T.nil 是一个与树中普通结点有相同属性的对象。它 的 ccolor 属性为BLACK ，而其他属性p、left、right 和key可以设为[.]。如图13- l ( b )所示，所有指向 NIL 的指针都用指向哨兵T.nil .
May 26 2018 07:20:17,50,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树add
May 26 2018 07:20:31,31,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树updata
May 26 2018 07:20:51,44,11,25,34,1.35,0.879,0.923,0.923,4,1,0.1208,0.0765,0.0765,0.0443,0.0087,线段树pushUp
May 26 2018 07:20:59,29,11,25,34,1.35,0.879,0.924,0.924,4,1,0.1208,0.0764,0.0764,0.0444,0.0088,线段树类型定义
May 26 2018 07:21:26,49,7,18,27,1.48,0.704,0.885,0.885,4,1,0.2962,0.1154,0.1154,0.1807,0.0744,线段树pushDown
May 27 2018 07:33:23,79,7,4,1,0.25,0.872,0.894,0.894,2,0,0.8723,0.8943,0.8943,-0.022,-0.0388,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 27 2018 07:34:38,83,11,4,1,0.25,0.747,0.693,0.843,2,0,0.7468,0.6925,0.8427,-0.0958,-0.1524,删除替换点
May 27 2018 07:35:39,62,6,15,24,1.62,0.74,0.891,0.891,4,1,0.2599,0.1093,0.1093,0.1506,0.0556,2
May 28 2018 10:13:26,79,1,2,1,0.5,0.954,0.89,0.89,2,0,0.9539,0.8895,0.8895,0.0644,0.1187,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 28 2018 10:13:59,83,1,2,7,3.55,0.954,0.89,0.89,3,1,0.0457,0.1104,0.1104,-0.0647,-0.0101,删除替换点
May 28 2018 10:14:35,34,13,2,1,0.5,0.945,0.929,0.929,2,0,0.9454,0.9295,0.9295,0.0159,0.0298,01二维
May 28 2018 10:15:18,35,13,30,35,1.17,0.968,0.93,0.93,4,1,0.0321,0.0705,0.0705,-0.0384,-0.0039,01二维
May 29 2018 09:17:55,18,13,45,20,0.45,0.571,0.644,0.827,4,1,0.4289,0.3563,0.1727,0.2562,0.1541,删除1
May 29 2018 09:18:13,41,14,31,59,1.9,0.822,0.919,0.919,4,1,0.1784,0.0811,0.0811,0.0974,0.0253,完全背包模板
May 29 2018 09:18:25,34,1,2,2,1.23,0.956,0.904,0.904,4,1,0.0442,0.0963,0.0963,-0.0521,-0.0073,01二维
May 29 2018 09:19:29,68,9,14,33,2.36,0.894,0.891,0.891,3,1,0.1063,0.1091,0.1091,-0.0028,-0.0006,1
May 29 2018 09:20:32,19,9,19,33,1.74,0.894,0.89,0.89,4,1,0.1063,0.1098,0.1098,-0.0035,-0.0008,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 29 2018 09:21:13,23,14,24,59,2.46,0.762,0.919,0.919,4,1,0.2382,0.0813,0.0813,0.1568,0.0501,5.一定要注意的问题：. 状态压缩数组大小都要开到[.]次方。
May 29 2018 09:21:54,69,9,2,1,0.5,0.82,0.891,0.891,2,0,0.8202,0.891,0.891,-0.0708,-0.1211,3
May 29 2018 09:22:27,45,9,2,1,0.5,0.893,0.891,0.891,2,0,0.8931,0.8907,0.8907,0.0024,0.0042,4
May 29 2018 09:23:25,79,1,2,1,0.5,0.952,0.903,0.903,2,0,0.9521,0.9033,0.9033,0.0488,0.0906,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 08:59:26,82,3,6,12,2.08,0.877,0.923,0.917,3,1,0.1228,0.0772,0.0832,0.0395,0.0081,找到替换点
May 30 2018 09:00:06,69,1,2,1,0.5,0.95,0.901,0.901,2,0,0.9498,0.9014,0.9014,0.0484,0.0895,3
May 30 2018 09:00:22,79,1,2,3,1.27,0.948,0.902,0.902,4,1,0.052,0.0985,0.0985,-0.0465,-0.007,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
May 30 2018 09:00:42,45,1,2,3,1.27,0.953,0.901,0.901,4,1,0.0475,0.0986,0.0986,-0.0511,-0.0075,4
May 30 2018 09:01:24,46,12,29,39,1.34,0.833,0.865,0.865,4,1,0.1668,0.135,0.135,0.0318,0.0096,线段树build
May 30 2018 09:02:19,65,6,11,9,0.8,0.925,0.842,0.842,4,1,0.0751,0.1577,0.1577,-0.0827,-0.0192,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 30 2018 09:02:41,47,12,30,39,1.29,0.837,0.865,0.865,4,1,0.1632,0.135,0.135,0.0282,0.0084,线段树search
May 30 2018 09:03:03,27,15,35,73,2.08,0.849,0.891,0.891,4,1,0.151,0.109,0.109,0.042,0.0109,01二维
May 31 2018 12:19:29,66,9,17,31,1.85,0.96,0.955,0.955,3,1,0.0398,0.0453,0.0453,-0.0055,-0.0005,我们可以在 O ( lgn )时间内完成向一棵含 n 个结点的红黑树中插入一个新结点。为了做到这一点，利用 TREE-INSERT 过程(参见12. 3 节）的一个略作修改的版本来将结点 z 插入树 T 内，就好像了是一棵普通的二叉搜索树一样，然后将 z 着为红色。（练 习 13. 3-1要求解释为什么选择将结点 z .
May 31 2018 12:19:52,34,2,4,5,1.19,0.916,0.901,0.901,4,1,0.0841,0.0989,0.0989,-0.0149,-0.0027,01二维
May 31 2018 12:20:04,60,9,13,31,2.42,0.901,0.955,0.955,4,1,0.0991,0.0453,0.0453,0.0537,0.0078,黑高
May 31 2018 12:20:24,69,1,2,3,1.39,0.95,0.887,0.887,4,1,0.0502,0.1131,0.1131,-0.0629,-0.0103,3
May 31 2018 12:21:19,42,8,13,11,0.82,0.931,0.832,0.832,4,1,0.0685,0.1683,0.1683,-0.0997,-0.0236,完全背包模板
May 31 2018 12:21:23,11,9,18,31,1.75,0.963,0.955,0.955,4,1,0.0369,0.0454,0.0454,-0.0085,-0.0007,*************************************************分割线. 树状数组  重点是在树状的数组. 大家都知道二叉树吧. 叶子结点代表A数组A[1]~A[8]. 现在变形一下.  现在定义每一列的顶端结点C[]数组 .  如下图. C[i]代表 子树的叶子结点的权值之和// 这里以求和举例 .
Jun 01 2018 09:08:12,84,12,23,37,1.63,0.769,0.916,0.916,4,1,0.2313,0.0842,0.0842,0.1472,0.0464,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;. [.].             w = x->p->rchild;.             if(w->color == RED) //情况1.             {.                 w .
Jun 01 2018 09:08:48,9,15,49,23,0.46,0.509,0.596,0.819,4,1,0.4913,0.404,0.1809,0.3104,0.2087,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:33,79,3,4,6,1.39,0.877,0.865,0.865,3,1,0.1234,0.1351,0.1351,-0.0117,-0.003,void rbDeleteFixup(rbtree **root_rbtree *x). {.     rbtree *w;.     while(x != *root && x->color == BLACK).     {.         if(x == x->p->lchild)  //第4行.         { .
Jun 02 2018 08:49:57,33,18,39,55,1.41,0.951,0.904,0.904,4,1,0.049,0.0958,0.0958,-0.0467,-0.0068,01二维
Jun 02 2018 08:50:10,38,18,32,55,1.72,0.896,0.904,0.904,4,1,0.1043,0.0961,0.0961,0.0082,0.0016,01一维
Jun 02 2018 08:50:34,45,3,6,6,0.93,0.877,0.865,0.865,4,1,0.1234,0.135,0.135,-0.0116,-0.003,4
Jun 02 2018 08:51:00,40,18,43,55,1.28,0.955,0.904,0.904,4,1,0.0447,0.0962,0.0962,-0.0515,-0.0073,完全背包模板
